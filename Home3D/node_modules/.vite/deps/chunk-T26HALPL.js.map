{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/audioUtils.ts", "../../../dev/core/src/AudioV2/webAudio/components/webAudioParameterComponent.ts", "../../../dev/core/src/AudioV2/abstractAudio/abstractAudioNode.ts", "../../../dev/core/src/AudioV2/abstractAudio/subProperties/abstractAudioAnalyzer.ts", "../../../dev/core/src/AudioV2/abstractAudio/subNodes/abstractAudioSubNode.ts", "../../../dev/core/src/AudioV2/abstractAudio/subNodes/volumeAudioSubNode.ts", "../../../dev/core/src/AudioV2/abstractAudio/subNodes/audioAnalyzerSubNode.ts", "../../../dev/core/src/AudioV2/abstractAudio/subProperties/audioAnalyzer.ts", "../../../dev/core/src/AudioV2/abstractAudio/abstractAudioOutNode.ts", "../../../dev/core/src/AudioV2/abstractAudio/subNodes/abstractAudioSubGraph.ts", "../../../dev/core/src/AudioV2/webAudio/subNodes/volumeWebAudioSubNode.ts", "../../../dev/core/src/AudioV2/webAudio/subNodes/webAudioAnalyzerSubNode.ts", "../../../dev/core/src/AudioV2/webAudio/subNodes/webAudioBaseSubGraph.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\nimport { AudioParameterRampShape } from \"./audioParameter\";\n\nexport const _FileExtensionRegex = new RegExp(\"\\\\.(\\\\w{3,4})($|\\\\?)\");\n\nconst CurveLength = 100;\n\nconst TmpLineValues = new Float32Array([0, 0]);\nlet TmpCurveValues: Nullable<Float32Array> = null;\n\nlet ExpCurve: Nullable<Float32Array> = null;\nlet LogCurve: Nullable<Float32Array> = null;\n\n/**\n * @returns A Float32Array representing an exponential ramp from (0, 0) to (1, 1).\n */\nfunction GetExpCurve(): Float32Array {\n    if (!ExpCurve) {\n        ExpCurve = new Float32Array(CurveLength);\n\n        const increment = 1 / (CurveLength - 1);\n        let x = increment;\n        for (let i = 1; i < CurveLength; i++) {\n            ExpCurve[i] = Math.exp(-11.512925464970227 * (1 - x));\n            x += increment;\n        }\n    }\n\n    return ExpCurve;\n}\n\n/**\n * @returns A Float32Array representing a logarithmic ramp from (0, 0) to (1, 1).\n */\nfunction GetLogCurve(): Float32Array {\n    if (!LogCurve) {\n        LogCurve = new Float32Array(CurveLength);\n\n        const increment = 1 / CurveLength;\n        let x = increment;\n        for (let i = 0; i < CurveLength; i++) {\n            LogCurve[i] = 1 + Math.log10(x) / Math.log10(CurveLength);\n            x += increment;\n        }\n    }\n\n    return LogCurve;\n}\n\n/** @internal */\nexport function _GetAudioParamCurveValues(shape: AudioParameterRampShape, from: number, to: number): Float32Array {\n    if (!TmpCurveValues) {\n        TmpCurveValues = new Float32Array(CurveLength);\n    }\n\n    let normalizedCurve: Float32Array;\n\n    if (shape === AudioParameterRampShape.Linear) {\n        TmpLineValues[0] = from;\n        TmpLineValues[1] = to;\n        return TmpLineValues;\n    } else if (shape === AudioParameterRampShape.Exponential) {\n        normalizedCurve = GetExpCurve();\n    } else if (shape === AudioParameterRampShape.Logarithmic) {\n        normalizedCurve = GetLogCurve();\n    } else {\n        throw new Error(`Unknown ramp shape: ${shape}`);\n    }\n\n    const direction = Math.sign(to - from);\n    const range = Math.abs(to - from);\n\n    if (direction === 1) {\n        for (let i = 0; i < normalizedCurve.length; i++) {\n            TmpCurveValues[i] = from + range * normalizedCurve[i];\n        }\n    } else {\n        let j = CurveLength - 1;\n        for (let i = 0; i < normalizedCurve.length; i++, j--) {\n            TmpCurveValues[i] = from - range * (1 - normalizedCurve[j]);\n        }\n    }\n\n    return TmpCurveValues;\n}\n\n/** @internal */\nexport function _CleanUrl(url: string) {\n    return url.replace(/#/gm, \"%23\");\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { IAudioParameterRampOptions } from \"../../audioParameter\";\nimport { AudioParameterRampShape } from \"../../audioParameter\";\nimport { _GetAudioParamCurveValues } from \"../../audioUtils\";\nimport type { _WebAudioEngine } from \"../webAudioEngine\";\n\n/**\n * Maximum time in seconds to wait for an active ramp to finish before starting a new ramp.\n *\n * New ramps will throw an error if the active ramp has more than this amount of time remaining.\n *\n * This is needed because short ramps are used to avoid pops and clicks when setting audio parameters, and we\n * don't want to throw an error if a short ramp is active.\n *\n * This constant is set to 11 milliseconds, which is short enough to avoid perceptual differences in most cases, but\n * long enough to allow for short ramps to be completed in a reasonable time frame.\n */\nconst MaxWaitTime = 0.011;\n\n/**\n * Minimum duration in seconds for a ramp to be considered valid.\n *\n * If the duration is less than this value, the value will be set immediately instead of being ramped smoothly since\n * there is no perceptual difference for such short durations, so a ramp is not needed.\n */\nconst MinRampDuration = 0.000001;\n\n/** @internal */\nexport class _WebAudioParameterComponent {\n    private _deferredRampOptions = {\n        duration: 0,\n        shape: AudioParameterRampShape.Linear,\n    };\n    private _deferredTargetValue = -1;\n    private _isObservingUpdates = false;\n    private _rampEndTime: number = 0;\n    private _engine: _WebAudioEngine;\n    private _param: AudioParam;\n    private _targetValue: number;\n\n    /** @internal */\n    constructor(engine: _WebAudioEngine, param: AudioParam) {\n        this._engine = engine;\n        this._param = param;\n        this._targetValue = param.value;\n    }\n\n    /** @internal */\n    public get isRamping(): boolean {\n        return this._engine.currentTime < this._rampEndTime;\n    }\n\n    /** @internal */\n    public get targetValue(): number {\n        return this._targetValue;\n    }\n\n    public set targetValue(value: number) {\n        this.setTargetValue(value);\n    }\n\n    /** @internal */\n    public get value(): number {\n        return this._param.value;\n    }\n\n    /** @internal */\n    public dispose(): void {\n        this._clearDeferredRamp();\n\n        this._param = null!;\n        this._engine = null!;\n    }\n\n    /**\n     * Sets the target value of the audio parameter with an optional ramping duration and shape.\n     *\n     * If a ramp is close to finishing, it will wait for the ramp to finish before setting the new value; otherwise it\n     * will throw an error because of a bug in Firefox that prevents active ramps from being cancelled with\n     * `cancelScheduledValues`. See https://bugzilla.mozilla.org/show_bug.cgi?id=1752775. Other browsers do not have\n     * this issue, but we throw an error in all browsers to ensure consistent behavior.\n     *\n     * There are other similar WebAudio APIs for ramping parameters, (e.g. `linearRampToValueAtTime` and\n     * `exponentialRampToValueAtTime`) but they don't work in Firefox and Meta Quest Chrome.\n     *\n     * It may be better in the long run to implement our own ramping logic with a WASM audio worklet instead of using\n     * `setValueCurveAtTime`. Another alternative is to use `setValueAtTime` wtih a custom shape, but that will\n     * probably be a performance hit to maintain quality at audio rates.\n     *\n     * @internal\n     */\n    public setTargetValue(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        if (this._targetValue === value) {\n            return;\n        }\n\n        const shape = typeof options?.shape === \"string\" ? options.shape : AudioParameterRampShape.Linear;\n\n        let duration = typeof options?.duration === \"number\" ? Math.max(options.duration, this._engine.parameterRampDuration) : this._engine.parameterRampDuration;\n        const startTime = this._engine.currentTime;\n\n        if (startTime < this._rampEndTime) {\n            const timeLeft = this._rampEndTime - startTime;\n\n            if (MaxWaitTime < timeLeft) {\n                throw new Error(\"Audio parameter not set. Wait for current ramp to finish.\");\n            } else {\n                this._deferRamp(value, duration, shape);\n                return;\n            }\n        }\n\n        if ((duration = Math.max(this._engine.parameterRampDuration, duration)) < MinRampDuration) {\n            this._param.setValueAtTime((this._targetValue = value), startTime);\n            return;\n        }\n\n        this._param.cancelScheduledValues(startTime);\n        this._param.setValueCurveAtTime(_GetAudioParamCurveValues(shape, this._targetValue, (this._targetValue = value)), startTime, duration);\n\n        this._clearDeferredRamp();\n\n        this._rampEndTime = startTime + duration;\n    }\n\n    private _deferRamp(value: number, duration: number, shape: AudioParameterRampShape): void {\n        this._deferredRampOptions.duration = duration;\n        this._deferredRampOptions.shape = shape;\n        this._deferredTargetValue = value;\n\n        if (!this._isObservingUpdates) {\n            this._engine._addUpdateObserver(this._applyDeferredRamp);\n            this._isObservingUpdates = true;\n        }\n    }\n\n    private _applyDeferredRamp = () => {\n        if (0 < this._deferredRampOptions.duration && this._rampEndTime < this._engine.currentTime) {\n            this.setTargetValue(this._deferredTargetValue, this._deferredRampOptions);\n        }\n    };\n\n    private _clearDeferredRamp(): void {\n        this._deferredRampOptions.duration = 0;\n\n        if (this._isObservingUpdates) {\n            this._engine._removeUpdateObserver(this._applyDeferredRamp);\n            this._isObservingUpdates = false;\n        }\n    }\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\n\nexport const enum AudioNodeType {\n    HAS_INPUTS = 1,\n    HAS_OUTPUTS = 2,\n    HAS_INPUTS_AND_OUTPUTS = 3,\n}\n\n/**\n * Abstract class for an audio node.\n *\n * An audio node is a processing unit that can receive audio data from an upstream node and/or send audio data to a\n * downstream node.\n *\n * Nodes can be connected to other nodes to create an audio graph. The audio graph represents the flow of audio data.\n *\n * There are 3 types of audio nodes:\n * 1. Input: Receives audio data from upstream nodes.\n * 2. Output: Sends audio data to downstream nodes.\n * 3. Input/Output: Receives audio data from upstream nodes and sends audio data to downstream nodes.\n */\nexport abstract class AbstractAudioNode {\n    /**\n     * The connected downstream audio nodes.\n     * - Undefined for input nodes.\n     */\n    protected readonly _downstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The connected upstream audio nodes.\n     * - Undefined for output nodes.\n     */\n    protected readonly _upstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The audio engine this node belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    /**\n     * Observable for when the audio node is disposed.\n     */\n    public readonly onDisposeObservable = new Observable<AbstractAudioNode>();\n\n    protected constructor(engine: AudioEngineV2, nodeType: AudioNodeType) {\n        this.engine = engine;\n\n        if (nodeType & AudioNodeType.HAS_INPUTS) {\n            this._upstreamNodes = new Set<AbstractAudioNode>();\n        }\n\n        if (nodeType & AudioNodeType.HAS_OUTPUTS) {\n            this._downstreamNodes = new Set<AbstractAudioNode>();\n        }\n    }\n\n    /**\n     * Releases associated resources.\n     * - Triggers `onDisposeObservable`.\n     * @see {@link onDisposeObservable}\n     */\n    public dispose(): void {\n        if (this._downstreamNodes) {\n            for (const node of Array.from(this._downstreamNodes)) {\n                if (!this._disconnect(node)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._downstreamNodes.clear();\n        }\n\n        if (this._upstreamNodes) {\n            for (const node of Array.from(this._upstreamNodes)) {\n                if (!node._disconnect(this)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._upstreamNodes.clear();\n        }\n\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    }\n\n    /**\n     * Gets a string identifying the name of the class\n     * @returns the class's name as a string\n     */\n    public abstract getClassName(): string;\n\n    /**\n     * Connect to a downstream audio input node.\n     * @param node - The downstream audio input node to connect\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    protected _connect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (this._downstreamNodes.has(node)) {\n            return false;\n        }\n\n        if (!node._onConnect(this)) {\n            return false;\n        }\n\n        this._downstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Disconnects a downstream audio input node.\n     * @param node - The downstream audio input node to disconnect\n     * @returns `true` if the node is successfully disconnected; otherwise `false`\n     */\n    protected _disconnect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (!this._downstreamNodes.delete(node)) {\n            return false;\n        }\n\n        return node._onDisconnect(this);\n    }\n\n    /**\n     * Called when an upstream audio output node is connecting.\n     * @param node - The connecting upstream audio node\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    private _onConnect(node: AbstractAudioNode): boolean {\n        if (!this._upstreamNodes) {\n            return false;\n        }\n\n        if (this._upstreamNodes.has(node)) {\n            return false;\n        }\n\n        this._upstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Called when an upstream audio output node disconnects.\n     * @param node - The disconnecting upstream audio node\n     * @returns `true` if node is sucessfully disconnected; otherwise `false`\n     */\n    private _onDisconnect(node: AbstractAudioNode): boolean {\n        return this._upstreamNodes?.delete(node) ?? false;\n    }\n}\n\n/**\n * Abstract class for a named audio node.\n */\nexport abstract class AbstractNamedAudioNode extends AbstractAudioNode {\n    private _name: string;\n\n    /**\n     * Observable for when the audio node is renamed.\n     */\n    public readonly onNameChangedObservable = new Observable<{ newName: string; oldName: string; node: AbstractNamedAudioNode }>();\n\n    protected constructor(name: string, engine: AudioEngineV2, nodeType: AudioNodeType) {\n        super(engine, nodeType);\n\n        this._name = name;\n    }\n\n    /**\n     * The name of the audio node.\n     * - Triggers `onNameChangedObservable` when changed.\n     * @see {@link onNameChangedObservable}\n     */\n    public get name(): string {\n        return this._name;\n    }\n\n    public set name(newName: string) {\n        if (this._name === newName) {\n            return;\n        }\n\n        const oldName = this._name;\n\n        this._name = newName;\n\n        this.onNameChangedObservable.notifyObservers({ newName, oldName, node: this });\n    }\n\n    public override dispose(): void {\n        super.dispose();\n\n        this.onNameChangedObservable.clear();\n    }\n}\n", "// eslint-disable-next-line @typescript-eslint/naming-convention\nexport type AudioAnalyzerFFTSizeType = 32 | 64 | 128 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768;\n\nexport const _AudioAnalyzerDefaults = {\n    fftSize: 2048 as AudioAnalyzerFFTSizeType,\n    minDecibels: -100 as number,\n    maxDecibels: -30 as number,\n    smoothing: 0.8 as number,\n} as const;\n\n/**\n * Options for the AudioAnalyzer\n */\nexport interface IAudioAnalyzerOptions {\n    /**\n     * Enable the audio analyzer. Defaults to false.\n     */\n    analyzerEnabled: boolean;\n    /**\n     * The size of the FFT (fast fourier transform) to use when converting time-domain data to frequency-domain data. Default is 2048.\n     */\n    analyzerFFTSize: AudioAnalyzerFFTSizeType;\n\n    /**\n     * The minimum decibel value for the range of the analyzer. Default is -100.\n     */\n    analyzerMinDecibels: number;\n\n    /**\n     * The maximum decibel value for the range of the analyzer. Default is -30.\n     */\n    analyzerMaxDecibels: number;\n\n    /**\n     * A number between 0 and 1 that determines how quickly the analyzer's value changes. Default is 0.8.\n     */\n    analyzerSmoothing: number;\n}\n\n/**\n * @param options The audio analyzer options to check.\n * @returns `true` if audio analyzer options are defined, otherwise `false`.\n */\nexport function _HasAudioAnalyzerOptions(options: Partial<IAudioAnalyzerOptions>): boolean {\n    return (\n        options.analyzerEnabled ||\n        options.analyzerFFTSize !== undefined ||\n        options.analyzerMinDecibels !== undefined ||\n        options.analyzerMaxDecibels !== undefined ||\n        options.analyzerSmoothing !== undefined\n    );\n}\n\n/**\n * An AudioAnalyzer converts time-domain audio data into the frequency-domain.\n */\nexport abstract class AbstractAudioAnalyzer {\n    /**\n     * The size of the FFT (fast fourier transform) to use when converting time-domain data to frequency-domain data. Default is 2048.\n     */\n    public abstract fftSize: AudioAnalyzerFFTSizeType;\n\n    /**\n     * The number of data values that will be returned when calling getByteFrequencyData() or getFloatFrequencyData(). This is always half the `fftSize`.\n     */\n    public get frequencyBinCount(): number {\n        return this.fftSize / 2;\n    }\n\n    /**\n     * Whether the analyzer is enabled or not.\n     * - The `getByteFrequencyData` and `getFloatFrequencyData` functions return `null` if the analyzer is not enabled.\n     * @see {@link enableAsync}\n     */\n    public abstract isEnabled: boolean;\n\n    /**\n     * The minimum decibel value for the range of the analyzer. Default is -100.\n     */\n    public abstract minDecibels: number;\n\n    /**\n     * The maximum decibel value for the range of the analyzer. Default is -30.\n     */\n    public abstract maxDecibels: number;\n\n    /**\n     * A number between 0 and 1 that determines how quickly the analyzer's value changes. Default is 0.8.\n     */\n    public abstract smoothing: number;\n\n    /**\n     * Releases associated resources.\n     */\n    public abstract dispose(): void;\n\n    /**\n     * Enables the analyzer\n     */\n    public abstract enableAsync(): Promise<void>;\n\n    /**\n     * Gets the current frequency data as a byte array\n     * @returns a Uint8Array if the analyzer is enabled, otherwise `null`\n     */\n    public abstract getByteFrequencyData(): Uint8Array;\n\n    /**\n     * Gets the current frequency data as a float array\n     * @returns a Float32Array if the analyzer is enabled, otherwise `null`\n     */\n    public abstract getFloatFrequencyData(): Float32Array;\n}\n", "import { AudioNodeType, AbstractNamedAudioNode } from \"../abstractAudioNode\";\nimport type { AudioEngineV2 } from \"../audioEngineV2\";\n\n/** @internal */\nexport abstract class _AbstractAudioSubNode extends AbstractNamedAudioNode {\n    /** @internal */\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine, AudioNodeType.HAS_INPUTS_AND_OUTPUTS);\n    }\n\n    /** @internal */\n    public connect(node: _AbstractAudioSubNode): void {\n        if (!this._connect(node)) {\n            throw new Error(\"Connect failed\");\n        }\n    }\n\n    /** @internal */\n    public disconnect(node: _AbstractAudioSubNode): void {\n        if (!this._disconnect(node)) {\n            throw new Error(\"Disconnect failed\");\n        }\n    }\n\n    /** @internal */\n    public disconnectAll(): void {\n        if (!this._downstreamNodes) {\n            throw new Error(\"Disconnect failed\");\n        }\n\n        const it = this._downstreamNodes.values();\n\n        for (let next = it.next(); !next.done; next = it.next()) {\n            if (!this._disconnect(next.value)) {\n                throw new Error(\"Disconnect failed\");\n            }\n        }\n    }\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { IAudioParameterRampOptions } from \"../../audioParameter\";\nimport type { AudioEngineV2 } from \"../audioEngineV2\";\nimport { _AbstractAudioSubNode } from \"../subNodes/abstractAudioSubNode\";\nimport { AudioSubNode } from \"../subNodes/audioSubNode\";\nimport type { _AbstractAudioSubGraph } from \"./abstractAudioSubGraph\";\n\n/** @internal */\nexport const _VolumeAudioDefaults = {\n    volume: 1 as number,\n} as const;\n\n/**\n * Volume options.\n */\nexport interface IVolumeAudioOptions {\n    /**\n     * The volume/gain. Defaults to 1.\n     */\n    volume: number;\n}\n\n/** @internal */\nexport abstract class _VolumeAudioSubNode extends _AbstractAudioSubNode {\n    protected constructor(engine: AudioEngineV2) {\n        super(AudioSubNode.VOLUME, engine);\n    }\n\n    public abstract volume: number;\n\n    /** @internal */\n    public setOptions(options: Partial<IVolumeAudioOptions>): void {\n        this.volume = options.volume ?? _VolumeAudioDefaults.volume;\n    }\n\n    /** @internal */\n    public abstract setVolume(value: number, options?: Nullable<Partial<IAudioParameterRampOptions>>): void;\n}\n\n/** @internal */\nexport function _GetVolumeAudioSubNode(subGraph: _AbstractAudioSubGraph): Nullable<_VolumeAudioSubNode> {\n    return subGraph.getSubNode<_VolumeAudioSubNode>(AudioSubNode.VOLUME);\n}\n\n/** @internal */\nexport function _GetVolumeAudioProperty<K extends keyof typeof _VolumeAudioDefaults>(subGraph: _AbstractAudioSubGraph, property: K): (typeof _VolumeAudioDefaults)[K] {\n    return _GetVolumeAudioSubNode(subGraph)?.[property] ?? _VolumeAudioDefaults[property];\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { AudioEngineV2 } from \"../audioEngineV2\";\nimport type { AudioAnalyzerFFTSizeType, IAudioAnalyzerOptions } from \"../subProperties/abstractAudioAnalyzer\";\nimport { _AudioAnalyzerDefaults } from \"../subProperties/abstractAudioAnalyzer\";\nimport type { _AbstractAudioSubGraph } from \"./abstractAudioSubGraph\";\nimport { _AbstractAudioSubNode } from \"./abstractAudioSubNode\";\nimport { AudioSubNode } from \"./audioSubNode\";\n\n/** @internal */\nexport abstract class _AudioAnalyzerSubNode extends _AbstractAudioSubNode {\n    protected constructor(engine: AudioEngineV2) {\n        super(AudioSubNode.ANALYZER, engine);\n    }\n\n    public abstract fftSize: AudioAnalyzerFFTSizeType;\n    public abstract minDecibels: number;\n    public abstract maxDecibels: number;\n    public abstract smoothing: number;\n\n    public abstract getByteFrequencyData(): Uint8Array;\n    public abstract getFloatFrequencyData(): Float32Array;\n\n    /** @internal */\n    public setOptions(options: Partial<IAudioAnalyzerOptions>): void {\n        this.fftSize = options.analyzerFFTSize ?? _AudioAnalyzerDefaults.fftSize;\n        this.minDecibels = options.analyzerMinDecibels ?? _AudioAnalyzerDefaults.minDecibels;\n        this.maxDecibels = options.analyzerMaxDecibels ?? _AudioAnalyzerDefaults.maxDecibels;\n        this.smoothing = options.analyzerSmoothing ?? _AudioAnalyzerDefaults.smoothing;\n    }\n}\n\n/** @internal */\nexport function _GetAudioAnalyzerSubNode(subGraph: _AbstractAudioSubGraph): Nullable<_AudioAnalyzerSubNode> {\n    return subGraph.getSubNode<_AudioAnalyzerSubNode>(AudioSubNode.ANALYZER);\n}\n\n/** @internal */\nexport function _SetAudioAnalyzerProperty<K extends keyof typeof _AudioAnalyzerDefaults>(subGraph: _AbstractAudioSubGraph, property: K, value: _AudioAnalyzerSubNode[K]): void {\n    subGraph.callOnSubNode<_AudioAnalyzerSubNode>(AudioSubNode.ANALYZER, (node) => {\n        node[property] = value;\n    });\n}\n", "import { Logger } from \"../../../Misc/logger\";\nimport type { Nullable } from \"../../../types\";\nimport type { AudioAnalyzerFFTSizeType } from \"../../abstractAudio/subProperties/abstractAudioAnalyzer\";\nimport { _AudioAnalyzerDefaults, AbstractAudioAnalyzer } from \"../../abstractAudio/subProperties/abstractAudioAnalyzer\";\nimport type { _AbstractAudioSubGraph } from \"../subNodes/abstractAudioSubGraph\";\nimport { _GetAudioAnalyzerSubNode, _SetAudioAnalyzerProperty } from \"../subNodes/audioAnalyzerSubNode\";\nimport { AudioSubNode } from \"../subNodes/audioSubNode\";\n\nlet EmptyByteFrequencyData: Nullable<Uint8Array> = null;\nlet EmptyFloatFrequencyData: Nullable<Float32Array> = null;\n\n/** @internal */\nexport function _GetEmptyByteFrequencyData(): Uint8Array {\n    if (!EmptyByteFrequencyData) {\n        EmptyByteFrequencyData = new Uint8Array();\n    }\n    return EmptyByteFrequencyData;\n}\n\n/** @internal */\nexport function _GetEmptyFloatFrequencyData(): Float32Array {\n    if (!EmptyFloatFrequencyData) {\n        EmptyFloatFrequencyData = new Float32Array();\n    }\n    return EmptyFloatFrequencyData;\n}\n\n/** @internal */\nexport class _AudioAnalyzer extends AbstractAudioAnalyzer {\n    private _fftSize: AudioAnalyzerFFTSizeType = _AudioAnalyzerDefaults.fftSize;\n    private _maxDecibels: number = _AudioAnalyzerDefaults.maxDecibels;\n    private _minDecibels: number = _AudioAnalyzerDefaults.minDecibels;\n    private _smoothing: number = _AudioAnalyzerDefaults.smoothing;\n    private _subGraph: _AbstractAudioSubGraph;\n\n    /** @internal */\n    public constructor(subGraph: _AbstractAudioSubGraph) {\n        super();\n        this._subGraph = subGraph;\n    }\n\n    /** @internal */\n    public get fftSize(): AudioAnalyzerFFTSizeType {\n        return this._fftSize;\n    }\n\n    public set fftSize(value: AudioAnalyzerFFTSizeType) {\n        this._fftSize = value;\n        _SetAudioAnalyzerProperty(this._subGraph, \"fftSize\", value);\n    }\n\n    /** @internal */\n    public get isEnabled(): boolean {\n        return _GetAudioAnalyzerSubNode(this._subGraph) !== null;\n    }\n\n    /** @internal */\n    public get minDecibels(): number {\n        return this._minDecibels;\n    }\n\n    public set minDecibels(value: number) {\n        this._minDecibels = value;\n        _SetAudioAnalyzerProperty(this._subGraph, \"minDecibels\", value);\n    }\n\n    /** @internal */\n    public get maxDecibels(): number {\n        return this._maxDecibels;\n    }\n\n    public set maxDecibels(value: number) {\n        this._maxDecibels = value;\n        _SetAudioAnalyzerProperty(this._subGraph, \"maxDecibels\", value);\n    }\n\n    /** @internal */\n    public get smoothing(): number {\n        return this._smoothing;\n    }\n\n    public set smoothing(value: number) {\n        this._smoothing = value;\n        _SetAudioAnalyzerProperty(this._subGraph, \"smoothing\", value);\n    }\n\n    /** @internal */\n    public dispose(): void {\n        const subNode = _GetAudioAnalyzerSubNode(this._subGraph);\n        if (subNode) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._subGraph.removeSubNodeAsync(subNode);\n            subNode.dispose();\n        }\n    }\n\n    /** @internal */\n    public async enableAsync(): Promise<void> {\n        const subNode = _GetAudioAnalyzerSubNode(this._subGraph);\n        if (!subNode) {\n            await this._subGraph.createAndAddSubNodeAsync(AudioSubNode.ANALYZER);\n        }\n    }\n\n    /** @internal */\n    public getByteFrequencyData(): Uint8Array {\n        const subNode = _GetAudioAnalyzerSubNode(this._subGraph);\n        if (!subNode) {\n            Logger.Warn(\"AudioAnalyzer not enabled\");\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.enableAsync();\n            return _GetEmptyByteFrequencyData();\n        }\n        return subNode.getByteFrequencyData();\n    }\n\n    /** @internal */\n    public getFloatFrequencyData(): Float32Array {\n        const subNode = _GetAudioAnalyzerSubNode(this._subGraph);\n        if (!subNode) {\n            Logger.Warn(\"AudioAnalyzer not enabled\");\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.enableAsync();\n            return _GetEmptyFloatFrequencyData();\n        }\n        return subNode.getFloatFrequencyData();\n    }\n}\n", "import type { Nullable } from \"../../types\";\nimport type { IAudioParameterRampOptions } from \"../audioParameter\";\nimport type { AudioNodeType } from \"./abstractAudioNode\";\nimport { AbstractNamedAudioNode } from \"./abstractAudioNode\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { _AbstractAudioSubGraph } from \"./subNodes/abstractAudioSubGraph\";\nimport type { IVolumeAudioOptions } from \"./subNodes/volumeAudioSubNode\";\nimport { _GetVolumeAudioProperty, _GetVolumeAudioSubNode } from \"./subNodes/volumeAudioSubNode\";\nimport type { AbstractAudioAnalyzer, IAudioAnalyzerOptions } from \"./subProperties/abstractAudioAnalyzer\";\nimport { _AudioAnalyzer } from \"./subProperties/audioAnalyzer\";\n\n/** @internal */\nexport interface IAbstractAudioOutNodeOptions extends IAudioAnalyzerOptions, IVolumeAudioOptions {}\n\n/**\n * Abstract class representing and audio output node with an analyzer and volume control.\n */\nexport abstract class AbstractAudioOutNode extends AbstractNamedAudioNode {\n    private _analyzer: Nullable<AbstractAudioAnalyzer> = null;\n\n    protected abstract _subGraph: _AbstractAudioSubGraph;\n\n    protected constructor(name: string, engine: AudioEngineV2, nodeType: AudioNodeType) {\n        super(name, engine, nodeType);\n    }\n\n    /**\n     * The analyzer features of the bus.\n     */\n    public get analyzer(): AbstractAudioAnalyzer {\n        return this._analyzer ?? (this._analyzer = new _AudioAnalyzer(this._subGraph));\n    }\n\n    /**\n     * The audio output volume.\n     */\n\n    public get volume(): number {\n        return _GetVolumeAudioProperty(this._subGraph, \"volume\");\n    }\n\n    public set volume(value: number) {\n        // The volume subnode is created on initialization and should always exist.\n        const node = _GetVolumeAudioSubNode(this._subGraph);\n        if (!node) {\n            throw new Error(\"No volume subnode\");\n        }\n\n        node.volume = value;\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this._analyzer?.dispose();\n        this._analyzer = null;\n\n        this._subGraph.dispose();\n    }\n\n    /**\n     * Sets the audio output volume with optional ramping.\n     * If the duration is 0 then the volume is set immediately, otherwise it is ramped to the new value over the given duration using the given shape.\n     * If a ramp is already in progress then the volume is not set and an error is thrown.\n     * @param value The value to set the volume to.\n     * @param options The options to use for ramping the volume change.\n     */\n    public setVolume(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        const node = _GetVolumeAudioSubNode(this._subGraph);\n        if (!node) {\n            throw new Error(\"No volume subnode\");\n        }\n\n        node.setVolume(value, options);\n    }\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { AbstractAudioNode, AbstractNamedAudioNode } from \"../abstractAudioNode\";\nimport type { _AbstractAudioSubNode } from \"./abstractAudioSubNode\";\nimport type { AudioSubNode } from \"./audioSubNode\";\n\n/**\n * Adds common sub graph functionality to an audio node.\n *\n * Audio nodes such as static sounds, streaming sounds, and buses can use audio sub graphs to process audio internally\n * before sending it to connected downstream audio nodes. This is useful for applying effects, spatial audio, and other\n * audio processing tasks common to multiple audio node classes.\n *\n * A key feature of audio sub graphs is their audio sub nodes are created asynchronously on demand so the minimum set\n * of sub nodes are used at all times to save memory and CPU resources. The tradeoff is a small delay when first\n * setting a property backed by a sub node. This delay is avoided by using the appropriate options to initialize the\n * sub node on creation, e.g. `spatialEnabled` and `stereoEnabled`, or by setting any creation option backed by the\n * sub node, e.g. `spatialPosition` and `stereoPan`.\n *\n * @internal\n */\nexport abstract class _AbstractAudioSubGraph {\n    private _createSubNodePromises: { [key: string]: Promise<_AbstractAudioSubNode> } = {};\n    private _isDisposed = false;\n    private _subNodes: { [key: string]: _AbstractAudioSubNode } = {};\n\n    /**\n     * Executes the given callback with the named sub node, creating the sub node if needed.\n     *\n     * @param name The name of the sub node\n     * @param callback The function to call with the named sub node\n     *\n     * @internal\n     */\n    public callOnSubNode<T extends _AbstractAudioSubNode>(name: AudioSubNode, callback: (node: T) => void): void {\n        const node = this.getSubNode(name);\n        if (node) {\n            callback(node as T);\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n        this._createSubNodePromisesResolvedAsync().then(() => {\n            const node = this.getSubNode(name);\n            if (node) {\n                callback(node as T);\n                return;\n            }\n\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n            this.createAndAddSubNodeAsync(name).then((node) => {\n                callback(node as T);\n            });\n        });\n    }\n\n    /**\n     * Creates the named subnode and adds it to the sub graph.\n     *\n     * @param name The name of the sub node.\n     * @returns A promise that resolves to the created sub node.\n     *\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public createAndAddSubNodeAsync(name: AudioSubNode): Promise<_AbstractAudioSubNode> {\n        // eslint-disable-next-line github/no-then\n        this._createSubNodePromises[name] ||= this._createSubNode(name).then((node) => {\n            this._addSubNode(node);\n            return node;\n        });\n\n        return this._createSubNodePromises[name];\n    }\n\n    /**\n     * Releases associated resources.\n     *\n     * @internal\n     */\n    public dispose() {\n        this._isDisposed = true;\n\n        const subNodes = Object.values(this._subNodes);\n        for (const subNode of subNodes) {\n            subNode.dispose();\n        }\n\n        this._subNodes = {};\n        this._createSubNodePromises = {};\n    }\n\n    /**\n     * Gets a previously created sub node.\n     *\n     * @param name - The name of the sub node\n     * @returns The named sub node, or `null` if it has not been created, yet\n     *\n     * @internal\n     * */\n    public getSubNode<T extends _AbstractAudioSubNode>(name: string): Nullable<T> {\n        return (this._subNodes[name] as T) ?? null;\n    }\n\n    /**\n     * Removes a sub node from the sub graph.\n     *\n     * @param subNode - The sub node to remove\n     * @returns A promise that resolves when the sub node is removed\n     *\n     * @internal\n     */\n    public async removeSubNodeAsync(subNode: _AbstractAudioSubNode): Promise<void> {\n        await this._createSubNodePromisesResolvedAsync();\n\n        const name = subNode.name;\n        if (this._subNodes[name]) {\n            delete this._subNodes[name];\n        }\n\n        delete this._createSubNodePromises[name];\n\n        this._onSubNodesChanged();\n    }\n\n    protected abstract _createSubNode(name: string): Promise<_AbstractAudioSubNode>;\n\n    /**\n     * Called when sub-nodes are added or removed.\n     * - Override this to connect and reconnect sub-nodes as needed.\n     */\n    protected abstract _onSubNodesChanged(): void;\n\n    protected async _createSubNodePromisesResolvedAsync(): Promise<_AbstractAudioSubNode[]> {\n        return await Promise.all(Object.values(this._createSubNodePromises));\n    }\n\n    private _addSubNode(node: _AbstractAudioSubNode): void {\n        if (this._isDisposed) {\n            node.dispose();\n            return;\n        }\n\n        this._subNodes[node.name] = node;\n\n        node.onDisposeObservable.addOnce(this._onSubNodeDisposed);\n\n        this._onSubNodesChanged();\n    }\n\n    private _onSubNodeDisposed = (node: AbstractAudioNode) => {\n        const subNode = node as AbstractNamedAudioNode;\n\n        delete this._subNodes[subNode.name];\n\n        this._onSubNodesChanged();\n    };\n}\n", "import type { Nullable } from \"../../../types\";\nimport { _VolumeAudioSubNode } from \"../../abstractAudio/subNodes/volumeAudioSubNode\";\nimport type { IAudioParameterRampOptions } from \"../../audioParameter\";\nimport { _WebAudioParameterComponent } from \"../components/webAudioParameterComponent\";\nimport type { _WebAudioEngine } from \"../webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioSubNode } from \"../webAudioNode\";\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function _CreateVolumeAudioSubNodeAsync(engine: _WebAudioEngine): Promise<_VolumeAudioSubNode> {\n    return new _VolumeWebAudioSubNode(engine);\n}\n\n/** @internal */\nexport class _VolumeWebAudioSubNode extends _VolumeAudioSubNode implements IWebAudioSubNode {\n    private _volume: _WebAudioParameterComponent;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public readonly node: AudioNode;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n\n        const gainNode = (this.node = new GainNode(engine._audioContext));\n        this._volume = new _WebAudioParameterComponent(engine, gainNode.gain);\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._volume.dispose();\n    }\n\n    /** @internal */\n    public get volume(): number {\n        return this._volume.value;\n    }\n\n    /** @internal */\n    public set volume(value: number) {\n        this.setVolume(value);\n    }\n\n    /** @internal */\n    public get _inNode(): AudioNode {\n        return this.node;\n    }\n\n    /** @internal */\n    public get _outNode(): AudioNode {\n        return this.node;\n    }\n\n    /** @internal */\n    public setVolume(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        this._volume.setTargetValue(value, options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this.node.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this.node.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_VolumeWebAudioSubNode\";\n    }\n}\n", "import type { Nullable } from \"../../../types\";\nimport { _AudioAnalyzerSubNode } from \"../../abstractAudio/subNodes/audioAnalyzerSubNode\";\nimport type { AudioAnalyzerFFTSizeType } from \"../../abstractAudio/subProperties/abstractAudioAnalyzer\";\nimport { _GetEmptyByteFrequencyData, _GetEmptyFloatFrequencyData } from \"../../abstractAudio/subProperties/audioAnalyzer\";\nimport type { _WebAudioEngine } from \"../webAudioEngine\";\nimport type { IWebAudioInNode } from \"../webAudioNode\";\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function _CreateAudioAnalyzerSubNodeAsync(engine: _WebAudioEngine): Promise<_AudioAnalyzerSubNode> {\n    return new _WebAudioAnalyzerSubNode(engine);\n}\n\n/** @internal */\nexport class _WebAudioAnalyzerSubNode extends _AudioAnalyzerSubNode implements IWebAudioInNode {\n    private readonly _analyzerNode: AnalyserNode;\n    private _byteFrequencyData: Nullable<Uint8Array> = null;\n    private _floatFrequencyData: Nullable<Float32Array> = null;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n\n        this._analyzerNode = new AnalyserNode(engine._audioContext);\n    }\n\n    /** @internal */\n    public get fftSize(): AudioAnalyzerFFTSizeType {\n        return this._analyzerNode.fftSize as AudioAnalyzerFFTSizeType;\n    }\n\n    public set fftSize(value: AudioAnalyzerFFTSizeType) {\n        if (value === this._analyzerNode.fftSize) {\n            return;\n        }\n\n        this._analyzerNode.fftSize = value;\n\n        this._clearArrays();\n    }\n\n    /** @internal */\n    public get _inNode(): AudioNode {\n        return this._analyzerNode;\n    }\n\n    /** @internal */\n    public get minDecibels(): number {\n        return this._analyzerNode.minDecibels;\n    }\n\n    public set minDecibels(value: number) {\n        this._analyzerNode.minDecibels = value;\n    }\n\n    /** @internal */\n    public get maxDecibels(): number {\n        return this._analyzerNode.maxDecibels;\n    }\n\n    public set maxDecibels(value: number) {\n        this._analyzerNode.maxDecibels = value;\n    }\n\n    /** @internal */\n    public get smoothing(): number {\n        return this._analyzerNode.smoothingTimeConstant;\n    }\n\n    public set smoothing(value: number) {\n        this._analyzerNode.smoothingTimeConstant = value;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._clearArrays();\n        this._byteFrequencyData = null;\n        this._floatFrequencyData = null;\n\n        this._analyzerNode.disconnect();\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioAnalyzerSubNode\";\n    }\n\n    /** @internal */\n    public getByteFrequencyData(): Uint8Array {\n        if (!this._byteFrequencyData || this._byteFrequencyData.length === 0) {\n            this._byteFrequencyData = new Uint8Array(this._analyzerNode.frequencyBinCount);\n        }\n        this._analyzerNode.getByteFrequencyData(this._byteFrequencyData);\n        return this._byteFrequencyData;\n    }\n\n    /** @internal */\n    public getFloatFrequencyData(): Float32Array {\n        if (!this._floatFrequencyData || this._floatFrequencyData.length === 0) {\n            this._floatFrequencyData = new Float32Array(this._analyzerNode.frequencyBinCount);\n        }\n        this._analyzerNode.getFloatFrequencyData(this._floatFrequencyData);\n        return this._floatFrequencyData;\n    }\n\n    private _clearArrays(): void {\n        this._byteFrequencyData?.set(_GetEmptyByteFrequencyData());\n        this._floatFrequencyData?.set(_GetEmptyFloatFrequencyData());\n    }\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { AbstractAudioNode } from \"../../abstractAudio/abstractAudioNode\";\nimport { _AbstractAudioSubGraph } from \"../../abstractAudio/subNodes/abstractAudioSubGraph\";\nimport type { _AbstractAudioSubNode } from \"../../abstractAudio/subNodes/abstractAudioSubNode\";\nimport { _GetAudioAnalyzerSubNode } from \"../../abstractAudio/subNodes/audioAnalyzerSubNode\";\nimport { AudioSubNode } from \"../../abstractAudio/subNodes/audioSubNode\";\nimport type { IVolumeAudioOptions } from \"../../abstractAudio/subNodes/volumeAudioSubNode\";\nimport { _GetVolumeAudioSubNode } from \"../../abstractAudio/subNodes/volumeAudioSubNode\";\nimport type { IAudioAnalyzerOptions } from \"../../abstractAudio/subProperties/abstractAudioAnalyzer\";\nimport { _HasAudioAnalyzerOptions } from \"../../abstractAudio/subProperties/abstractAudioAnalyzer\";\nimport type { IWebAudioInNode, IWebAudioSuperNode } from \"../webAudioNode\";\nimport type { _VolumeWebAudioSubNode } from \"./volumeWebAudioSubNode\";\nimport { _CreateVolumeAudioSubNodeAsync } from \"./volumeWebAudioSubNode\";\nimport { _CreateAudioAnalyzerSubNodeAsync } from \"./webAudioAnalyzerSubNode\";\n\n/**\n * Options for creating a WebAudioBaseSubGraph.\n */\nexport interface IWebAudioBaseSubGraphOptions extends IAudioAnalyzerOptions, IVolumeAudioOptions {}\n\n/** @internal */\nexport abstract class _WebAudioBaseSubGraph extends _AbstractAudioSubGraph {\n    protected _owner: IWebAudioSuperNode;\n    protected _outputNode: Nullable<AudioNode> = null;\n\n    /** @internal */\n    public constructor(owner: IWebAudioSuperNode) {\n        super();\n\n        this._owner = owner;\n    }\n\n    /** @internal */\n    public async initAsync(options: Partial<IWebAudioBaseSubGraphOptions>): Promise<void> {\n        const hasAnalyzerOptions = _HasAudioAnalyzerOptions(options);\n\n        if (hasAnalyzerOptions) {\n            await this.createAndAddSubNodeAsync(AudioSubNode.ANALYZER);\n        }\n\n        await this.createAndAddSubNodeAsync(AudioSubNode.VOLUME);\n\n        await this._createSubNodePromisesResolvedAsync();\n\n        if (hasAnalyzerOptions) {\n            const analyzerNode = _GetAudioAnalyzerSubNode(this);\n            if (!analyzerNode) {\n                throw new Error(\"No analyzer subnode.\");\n            }\n\n            analyzerNode.setOptions(options);\n        }\n\n        const volumeNode = _GetVolumeAudioSubNode(this);\n        if (!volumeNode) {\n            throw new Error(\"No volume subnode.\");\n        }\n\n        volumeNode.setOptions(options);\n\n        if (volumeNode.getClassName() !== \"_VolumeWebAudioSubNode\") {\n            throw new Error(\"Not a WebAudio subnode.\");\n        }\n\n        this._outputNode = (volumeNode as _VolumeWebAudioSubNode).node;\n\n        // Connect the new wrapped WebAudio node to the wrapped downstream WebAudio nodes.\n        // The wrapper nodes are unaware of this change.\n        if (this._outputNode && this._downstreamNodes) {\n            const it = this._downstreamNodes.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                const inNode = (next.value as IWebAudioInNode)._inNode;\n                if (inNode) {\n                    this._outputNode.connect(inNode);\n                }\n            }\n        }\n    }\n\n    protected abstract readonly _downstreamNodes: Nullable<Set<AbstractAudioNode>>;\n\n    /** @internal */\n    public get _inNode(): Nullable<AudioNode> {\n        return this._outputNode;\n    }\n\n    /** @internal */\n    public get _outNode(): Nullable<AudioNode> {\n        return this._outputNode;\n    }\n\n    // Function is async, but throws synchronously. Avoiding breaking changes.\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    protected _createSubNode(name: string): Promise<_AbstractAudioSubNode> {\n        switch (name) {\n            case AudioSubNode.ANALYZER:\n                return _CreateAudioAnalyzerSubNodeAsync(this._owner.engine);\n            case AudioSubNode.VOLUME:\n                return _CreateVolumeAudioSubNodeAsync(this._owner.engine);\n            default:\n                throw new Error(`Unknown subnode name: ${name}`);\n        }\n    }\n\n    protected _onSubNodesChanged(): void {\n        const analyzerNode = _GetAudioAnalyzerSubNode(this);\n        const volumeNode = _GetVolumeAudioSubNode(this);\n\n        if (analyzerNode && volumeNode) {\n            volumeNode.connect(analyzerNode);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["AudioNodeType", "node"]
}
