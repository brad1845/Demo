import {
  ApplyPostProcess,
  CubeMapToSphericalPolynomialTools
} from "./chunk-WGFKKAGM.js";
import {
  PostProcess
} from "./chunk-AGEA2LS6.js";
import {
  BaseTexture
} from "./chunk-AZQ3YFCD.js";

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools = class {
  /**
   * Expand the RGBD Texture from RGBD to Half Float if possible.
   * @param texture the texture to expand.
   */
  static ExpandRGBDTexture(texture) {
    const internalTexture = texture._texture;
    if (!internalTexture || !texture.isRGBD) {
      return;
    }
    const engine = internalTexture.getEngine();
    const caps = engine.getCaps();
    const isReady = internalTexture.isReady;
    let expandTexture = false;
    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 1;
    }
    if (expandTexture) {
      internalTexture.isReady = false;
      internalTexture._isRGBD = false;
      internalTexture.invertY = false;
    }
    const expandRgbdTextureAsync = async () => {
      const isWebGpu = engine.isWebGPU;
      const shaderLanguage = isWebGpu ? 1 : 0;
      internalTexture.isReady = false;
      if (isWebGpu) {
        await import("./rgbdDecode.fragment-YNB3EJMU.js");
      } else {
        await import("./rgbdDecode.fragment-NXJPEAVX.js");
      }
      const rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false, void 0, shaderLanguage);
      rgbdPostProcess.externalTextureSamplerBinding = true;
      const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
        generateDepthBuffer: false,
        generateMipMaps: false,
        generateStencilBuffer: false,
        samplingMode: internalTexture.samplingMode,
        type: internalTexture.type,
        format: 5
      });
      rgbdPostProcess.onEffectCreatedObservable.addOnce((e) => {
        e.executeWhenCompiled(() => {
          rgbdPostProcess.onApply = (effect) => {
            effect._bindTexture("textureSampler", internalTexture);
            effect.setFloat2("scale", 1, 1);
          };
          texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);
          engine.restoreDefaultFramebuffer();
          engine._releaseTexture(internalTexture);
          if (rgbdPostProcess) {
            rgbdPostProcess.dispose();
          }
          expandedTexture._swapAndDie(internalTexture);
          internalTexture.isReady = true;
        });
      });
    };
    if (expandTexture) {
      if (isReady) {
        expandRgbdTextureAsync();
      } else {
        texture.onLoadObservable.addOnce(expandRgbdTextureAsync);
      }
    }
  }
  /**
   * Encode the texture to RGBD if possible.
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param outputTextureType type of the texture in which the encoding is performed
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  // Should have "Async" in the name but this is a breaking change.
  // eslint-disable-next-line no-restricted-syntax
  static async EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
    if (!scene.getEngine().isWebGPU) {
      await import("./rgbdEncode.fragment-ACYWXZXZ.js");
    } else {
      await import("./rgbdEncode.fragment-XQ6EU2YS.js");
    }
    return await ApplyPostProcess("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
  }
};

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js
BaseTexture.prototype.forceSphericalPolynomialsRecompute = function() {
  if (this._texture) {
    this._texture._sphericalPolynomial = null;
    this._texture._sphericalPolynomialPromise = null;
    this._texture._sphericalPolynomialComputed = false;
  }
};
Object.defineProperty(BaseTexture.prototype, "sphericalPolynomial", {
  get: function() {
    if (this._texture) {
      if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {
        return this._texture._sphericalPolynomial;
      }
      if (this._texture.isReady) {
        if (!this._texture._sphericalPolynomialPromise) {
          this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
          if (this._texture._sphericalPolynomialPromise === null) {
            this._texture._sphericalPolynomialComputed = true;
          } else {
            this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {
              this._texture._sphericalPolynomial = sphericalPolynomial;
              this._texture._sphericalPolynomialComputed = true;
            });
          }
        }
        return null;
      }
    }
    return null;
  },
  set: function(value) {
    if (this._texture) {
      this._texture._sphericalPolynomial = value;
    }
  },
  enumerable: true,
  configurable: true
});

export {
  RGBDTextureTools
};
//# sourceMappingURL=chunk-XXOZVP2O.js.map
