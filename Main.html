<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced Camera Toggle VR Scene</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { 
      margin: 0; 
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    }
    
    .camera-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 12px;
      color: white;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .control-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .control-row:last-child {
      margin-bottom: 0;
    }
    
    .toggle-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .toggle-btn:active {
      transform: translateY(0);
    }
    
    .mode-label {
      font-weight: bold;
      font-size: 16px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }
    
    .camera-info {
      font-size: 12px;
      color: #b0b0b0;
      margin-top: 8px;
      font-family: 'Courier New', monospace;
    }
    
    .position-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .rotation-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .instructions {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.85);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      max-width: 280px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .instructions h4 {
      margin: 0 0 10px 0;
      color: #00ff88;
      font-size: 14px;
    }
    
    .control-group {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    
    .performance-info {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 6px;
      color: #00ff88;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      border: 1px solid rgba(0, 255, 136, 0.2);
    }
    
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      pointer-events: none;
      width: 24px;
      height: 24px;
    }
    
    .crosshair-circle {
      width: 100%;
      height: 100%;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      background: transparent;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1);
      animation: crosshair-pulse 2s ease-in-out infinite alternate;
    }
    
    @keyframes crosshair-pulse {
      0% {
        border-color: rgba(255, 255, 255, 0.6);
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.2), inset 0 0 8px rgba(255, 255, 255, 0.05);
      }
      100% {
        border-color: rgba(255, 255, 255, 1);
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.5), inset 0 0 15px rgba(255, 255, 255, 0.2);
      }
    }
  </style>
</head>
<body>
  <div class="camera-controls">
    <div class="control-row">
      <button id="toggleBtn" class="toggle-btn">切換相機</button>
      <span id="modeLabel" class="mode-label">透視模式</span>
    </div>
    <div id="cameraInfo" class="camera-info">FOV: 60° | 透視投影</div>
    <div id="positionInfo" class="position-info">位置: (0.0, 1.6, 3.0)</div>
    <div id="rotationInfo" class="rotation-info">旋轉: (0°, 0°, 0°)</div>
  </div>
  
  <div class="performance-info" id="performanceInfo">
    FPS: -- | 物件: --
  </div>
  
  <!-- 視線中心指示器 -->
  <div class="crosshair" id="crosshair">
    <div class="crosshair-circle"></div>
  </div>
  
  <div class="instructions">
    <h4>🎮 控制說明</h4>
    <div class="control-group">
      <span class="key">滑鼠拖曳</span> 旋轉視角<br>
      <span class="key">WASD</span> / <span class="key">方向鍵</span> 移動相機
    </div>
    <div class="control-group">
      <span class="key">空白鍵</span> 切換相機模式<br>
      <span class="key">滾輪</span> 縮放 (透視模式)
    </div>
    <div class="control-group">
      <span class="key">WS</span> 調整正交尺寸 (正交模式)<br>
      <span class="key">R</span> 重置相機位置<br>
      <span class="key">C</span> 切換視線指示器
    </div>
  </div>

  <a-scene id="mainScene" background="color: #0f0f23" fog="type: exponential; color: #0f0f23; density: 0.02">
    <a-entity id="cameraRig" position="0 1.6 3">
      <a-camera id="cam" look-controls wasd-controls="enabled: false"></a-camera>
    </a-entity>
    
    <!-- 創建一個更豐富的3D場景 -->
    
    <!-- 右側靜態方塊（用於測試視覺匹配） -->
    <a-box position="4 1.6 0" rotation="0 0 0" color="#e74c3c" 
           material="metalness: 0.3; roughness: 0.6"></a-box>
    
    <!-- 正前方靜態球體（主要測試目標） -->
    <a-sphere position="0 1.6 -3" radius="0.5" color="#f39c12" 
              material="metalness: 0.4; roughness: 0.5"></a-sphere>
    
    <!-- 左前方靜態圓環 -->
    <a-torus position="-2 1.6 -4" color="#9b59b6" radius="0.6" radius-tubular="0.15"
             material="metalness: 0.6; roughness: 0.3"></a-torus>
    
    <!-- 地板和牆壁 -->
    <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" 
             color="#2c3e50" material="metalness: 0.1; roughness: 0.9"></a-plane>
    
    <!-- 背景牆 -->
    <a-plane position="0 5 -10" rotation="0 0 0" width="20" height="10" 
             color="#34495e" material="opacity: 0.7; transparent: true"></a-plane>
    
    <!-- 增強光源系統 -->
    <a-light type="ambient" color="#404040" intensity="0.3"></a-light>
    <a-light type="point" position="3 5 3" color="#ffffff" intensity="0.8" 
             animation="property: position; to: -3 5 -3; dir: alternate; loop: true; dur: 10000"></a-light>
    <a-light type="point" position="-3 5 3" color="#ff6b6b" intensity="0.6"
             animation="property: position; to: 3 5 -3; dir: alternate; loop: true; dur: 8000"></a-light>
    <a-light type="directional" position="0 10 0" color="#87ceeb" intensity="0.4"></a-light>
  </a-scene>

  <script>
    class EnhancedCameraController {
      constructor() {
        this.sceneEl = document.querySelector("a-scene");
        this.camEntity = document.getElementById("cam");
        this.cameraRig = document.getElementById("cameraRig");
        this.label = document.getElementById("modeLabel");
        this.toggleBtn = document.getElementById("toggleBtn");
        this.cameraInfo = document.getElementById("cameraInfo");
        this.positionInfo = document.getElementById("positionInfo");
        this.rotationInfo = document.getElementById("rotationInfo");
        this.performanceInfo = document.getElementById("performanceInfo");
        this.crosshair = document.getElementById("crosshair");
        
        this.isOrtho = false;
        this.orthoCam = null;
        this.perspCam = null;
        this.orthoSize = 5;
        
        // 相機狀態保存
        this.savedState = {
          position: new THREE.Vector3(0, 1.6, 3),
          rotation: new THREE.Euler(),
          quaternion: new THREE.Quaternion()
        };
        
        // 保存透視相機的FOV值
        this.savedPerspectiveFov = 60;
        
        // 移動控制
        this.keys = {};
        this.moveSpeed = 0.1; // 統一的移動速度
        this.smoothing = 0.1;
        this.velocity = new THREE.Vector3();
        this.acceleration = 0.02;
        this.friction = 0.9;
        
        // 正交尺寸控制
        this.targetOrthoSize = 5;
        this.orthoSizeVelocity = 0;
        this.orthoSizeSpeed = 0.15;
        
        // 滑鼠狀態
        this.isMouseDown = false;
        this.isTouchDown = false;
        
        // 性能監控
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
        this.frameTimeBuffer = [];
        this.bufferSize = 60; // 使用60帧来计算平均FPS
        
        // 默認相機位置
        this.defaultPosition = new THREE.Vector3(0, 1.6, 3);
        this.defaultRotation = new THREE.Euler(0, 0, 0);
        
        // 視線中心指示器狀態
        this.crosshairVisible = true;
        
        // 視覺匹配：基於視線方向的距離檢測
        this.defaultOrthoSize = 21.9; // 默認正交尺寸
        
        // 当前视线距离缓存，用于保持视觉一致性
        this.currentViewDistance = null;
        
        // 調試模式（設為 true 可在控制台看到詳細信息）
        this.debugMode = false;
        
        this.init();
      }
      
      init() {
        this.sceneEl.addEventListener("loaded", () => {
          // 立即替換默認相機，確保從一開始就使用統一的相機系統
          const aspect = window.innerWidth / window.innerHeight;
          this.perspCam = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
          
          // 設置初始位置和旋轉
          this.perspCam.position.copy(this.defaultPosition);
          this.perspCam.rotation.copy(this.defaultRotation);
          this.perspCam.quaternion.setFromEuler(this.defaultRotation);
          this.perspCam.updateMatrix();
          this.perspCam.updateMatrixWorld(true);
          this.perspCam.updateProjectionMatrix();
          
          // 同步A-Frame實體狀態
          this.camEntity.object3D.position.copy(this.perspCam.position);
          this.camEntity.object3D.rotation.copy(this.perspCam.rotation);
          this.camEntity.object3D.quaternion.copy(this.perspCam.quaternion);
          this.camEntity.object3D.updateMatrix();
          this.camEntity.object3D.updateMatrixWorld(true);
          
          // 替換默認相機
          this.camEntity.setObject3D("camera", this.perspCam);
          this.sceneEl.camera = this.perspCam;
          
          this.updateCameraInfo();
          this.setupEventListeners();
          this.startPerformanceMonitoring();
          this.animate();
        });
      }
      
      setupEventListeners() {
        // 按鈕切換
        this.toggleBtn.addEventListener("click", () => this.toggleCamera());
        
        // 鍵盤控制
        document.addEventListener("keydown", (e) => this.handleKeyDown(e));
        document.addEventListener("keyup", (e) => this.handleKeyUp(e));
        
        // 滾輪縮放
        this.sceneEl.addEventListener("wheel", (e) => this.handleWheel(e), { passive: false });
        
        // 視窗大小變化
        window.addEventListener("resize", () => this.handleResize());
        
        // 使用 setInterval 定期更新旋轉信息
        setInterval(() => {
          this.updatePositionInfo();
        }, 50); // 每50毫秒更新一次（20 FPS）
      }
      
      handleKeyDown(e) {
        if (e.repeat) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            this.toggleCamera();
            break;
          case 'KeyR':
            e.preventDefault();
            this.resetCamera();
            break;
          case 'KeyC':
            e.preventDefault();
            this.toggleCrosshair();
            break;
          case 'KeyG':
            e.preventDefault();
            this.debugMode = !this.debugMode;
            console.log(`調試模式: ${this.debugMode ? '開啟' : '關閉'}`);
            break;
          case 'KeyW':
            if (this.isOrtho) {
              e.preventDefault();
              this.keys.orthoShrink = true;
            } else {
              this.keys.forward = true;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              e.preventDefault();
              this.keys.orthoGrow = true;
            } else {
              this.keys.backward = true;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = true;
            break;
          case 'ArrowDown':
            this.keys.backward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = true;
            break;
        }
      }
      
      handleKeyUp(e) {
        switch(e.code) {
          case 'KeyW':
            if (this.isOrtho) {
              this.keys.orthoShrink = false;
            } else {
              this.keys.forward = false;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              this.keys.orthoGrow = false;
            } else {
              this.keys.backward = false;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = false;
            break;
          case 'ArrowDown':
            this.keys.backward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = false;
            break;
        }
      }
      
      handleWheel(e) {
        if (!this.isOrtho && this.perspCam) {
          e.preventDefault();
          const currentFov = this.perspCam.fov;
          const delta = e.deltaY * 0.1;
          const newFov = Math.max(10, Math.min(120, currentFov + delta));
          
          this.perspCam.fov = newFov;
          this.savedPerspectiveFov = newFov; // 同步保存FOV值
          this.perspCam.updateProjectionMatrix();
          this.updateCameraInfo();
        }
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        
        // 更新移動
        this.updateMovement();
        
        // 更新正交尺寸（如果在正交模式）
        this.updateOrthoSize();
        
        // 更新性能信息
        this.updatePerformanceInfo();
        
        this.frameCount++;
      }
      
      updateMovement() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return;
        
        // 計算目標移動方向
        const targetVelocity = new THREE.Vector3();
        
        if (this.keys.forward) targetVelocity.z -= 1;
        if (this.keys.backward) targetVelocity.z += 1;
        if (this.keys.left) targetVelocity.x -= 1;
        if (this.keys.right) targetVelocity.x += 1;
        
        // 正規化移動向量並應用統一速度
        if (targetVelocity.length() > 0) {
          targetVelocity.normalize();
          targetVelocity.multiplyScalar(this.moveSpeed);
        }
        
        // 平滑移動
        this.velocity.lerp(targetVelocity, 0.3);
        
        // 應用摩擦力
        if (targetVelocity.length() === 0) {
          this.velocity.multiplyScalar(this.friction);
        }
        
        // 如果速度很小就停止
        if (this.velocity.length() < 0.001) {
          this.velocity.set(0, 0, 0);
        }
        
        // 應用移動到相機
        if (this.velocity.length() > 0) {
          const moveVector = this.velocity.clone();
          // 使用相機的四元數來變換移動方向
          moveVector.applyQuaternion(currentCamera.quaternion);
          
          // 直接更新相機位置
          currentCamera.position.add(moveVector);
          
          // 同步A-Frame實體位置
          this.camEntity.object3D.position.copy(currentCamera.position);
          this.camEntity.setAttribute('position', {
            x: currentCamera.position.x,
            y: currentCamera.position.y,
            z: currentCamera.position.z
          });
        }
      }
      
      saveCameraState() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          currentCamera.updateMatrixWorld(true);
          this.savedState.position.copy(currentCamera.position);
          this.savedState.rotation.copy(currentCamera.rotation);
          this.savedState.quaternion.copy(currentCamera.quaternion);
          
          // 保存透視相機的FOV
          if (currentCamera.isPerspectiveCamera) {
            this.savedPerspectiveFov = currentCamera.fov;
          }
        }
      }
      
      restoreCameraState(newCamera) {
        if (newCamera) {
          newCamera.position.copy(this.savedState.position);
          newCamera.rotation.copy(this.savedState.rotation);
          newCamera.quaternion.copy(this.savedState.quaternion);
          
          // 確保矩陣狀態完全同步
          newCamera.updateMatrix();
          newCamera.updateMatrixWorld(true);
          newCamera.updateProjectionMatrix();
          
          // 同步A-Frame實體的變換狀態
          const cameraEl = this.camEntity;
          cameraEl.object3D.position.copy(newCamera.position);
          cameraEl.object3D.rotation.copy(newCamera.rotation);
          cameraEl.object3D.quaternion.copy(newCamera.quaternion);
          cameraEl.object3D.updateMatrix();
          cameraEl.object3D.updateMatrixWorld(true);
          
          // 同步到A-Frame的attribute系統
          cameraEl.setAttribute('position', {
            x: newCamera.position.x,
            y: newCamera.position.y,
            z: newCamera.position.z
          });
          cameraEl.setAttribute('rotation', {
            x: THREE.MathUtils.radToDeg(newCamera.rotation.x),
            y: THREE.MathUtils.radToDeg(newCamera.rotation.y),
            z: THREE.MathUtils.radToDeg(newCamera.rotation.z)
          });
        }
      }
      
      // 簡化的射線檢測（專為室內場景優化）
      getViewDirectionDistance(camera) {
        const raycaster = new THREE.Raycaster();
        const origin = new THREE.Vector3();
        const direction = new THREE.Vector3(0, 0, -1);
        
        // 設置射線起點和方向
        camera.getWorldPosition(origin);
        direction.transformDirection(camera.matrixWorld);
        raycaster.set(origin, direction);
        
        // 收集場景中的實體物體（排除輔助元素）
        const meshes = [];
        this.sceneEl.object3D.traverse((child) => {
          if (child.isMesh && child.visible && child.geometry) {
            // 簡單過濾：排除相機和網格輔助線
            const parentEl = child.parent?.el;
            if (parentEl?.id && ['grid', 'cameraRig', 'cam'].includes(parentEl.id)) {
              return;
            }
            meshes.push(child);
          }
        });
        
        // 執行射線檢測
        const intersects = raycaster.intersectObjects(meshes, false);
        
        if (intersects.length > 0) {
          const distance = intersects[0].distance;
          // 室內空間範圍：最近0.3米（牆壁），最遠30米（長走廊/大廳）
          return Math.max(0.3, Math.min(30, distance));
        }
        
        // 沒有命中時的默認距離（中等房間尺寸）
        return 8.0;
      }
      
      // 使用射線檢測的正交尺寸計算
      calculateOptimalOrthoSize() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return 5.0;
        
        // 獲取當前FOV
        let currentFov = 60;
        if (!this.isOrtho && this.perspCam) {
          currentFov = this.perspCam.fov;
        } else if (this.savedPerspectiveFov) {
          currentFov = this.savedPerspectiveFov;
        }
        
        // 檢測視線方向的距離
        const distance = this.getViewDirectionDistance(currentCamera);
        
        // 應用數學公式：s = 2 * tan(fov/2) * d
        const fovRadians = THREE.MathUtils.degToRad(currentFov);
        const orthoSize = 2 * Math.tan(fovRadians / 2) * distance;
        
        return Math.max(0.2, Math.min(80, orthoSize));
      }
      
      // 反向計算FOV（當調整正交尺寸時）
      calculateCorrespondingFov(orthoSize) {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return 60;
        
        const distance = this.getViewDirectionDistance(currentCamera);
        
        // 從正交尺寸反推FOV
        const tanHalfFov = orthoSize / (2 * distance);
        const fovRadians = 2 * Math.atan(tanHalfFov);
        const fovDegrees = THREE.MathUtils.radToDeg(fovRadians);
        
        return Math.max(10, Math.min(120, fovDegrees));
      }
      
      // 切換視線中心指示器的顯示/隱藏
      toggleCrosshair() {
        this.crosshairVisible = !this.crosshairVisible;
        this.crosshair.style.display = this.crosshairVisible ? 'block' : 'none';
      }
      
      // 根據相機模式調整視線指示器樣式
      updateCrosshairStyle() {
        if (!this.crosshair) return;
        
        const circle = this.crosshair.querySelector('.crosshair-circle');
        if (!circle) return;
        
        if (this.isOrtho) {
          // 正交模式：更實心一點的樣式
          circle.style.borderColor = 'rgba(0, 255, 136, 0.9)';
          circle.style.boxShadow = '0 0 12px rgba(0, 255, 136, 0.4), inset 0 0 12px rgba(0, 255, 136, 0.15)';
        } else {
          // 透視模式：原始樣式
          circle.style.borderColor = 'rgba(255, 255, 255, 0.8)';
          circle.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1)';
        }
      }
      
      toggleCamera() {
        this.saveCameraState();
        
        if (!this.isOrtho) {
          this.switchToOrthographic();
        } else {
          this.switchToPerspective();
        }
        
        this.updateCameraInfo();
        this.updateVisualEffects();
        this.updateCrosshairStyle();
      }
      
      switchToOrthographic() {
        const aspect = window.innerWidth / window.innerHeight;
        
        // 基于当前透视相机的FOV和当前视线距离计算正交尺寸
        const currentFov = this.perspCam ? this.perspCam.fov : this.savedPerspectiveFov || 60;
        const currentDistance = this.getViewDirectionDistance(this.perspCam || this.camEntity.getObject3D("camera"));
        
        // 使用当前FOV和距离计算正交尺寸，保持视觉一致性
        const fovRadians = THREE.MathUtils.degToRad(currentFov);
        this.orthoSize = 2 * Math.tan(fovRadians / 2) * currentDistance;
        this.orthoSize = Math.max(0.2, Math.min(80, this.orthoSize));
        
        // 保存当前的视线距离，用于后续的FOV计算
        this.currentViewDistance = currentDistance;
        
        this.orthoCam = new THREE.OrthographicCamera(
          -this.orthoSize * aspect / 2, 
          this.orthoSize * aspect / 2,
          this.orthoSize / 2, 
          -this.orthoSize / 2,
          0.1, 
          1000
        );
        
        this.restoreCameraState(this.orthoCam);
        
        this.camEntity.setObject3D("camera", this.orthoCam);
        this.sceneEl.camera = this.orthoCam;
        
        // 重置速度避免切換後的移動問題
        this.velocity.set(0, 0, 0);
        this.orthoSizeVelocity = 0;
        
        this.label.textContent = "正交模式";
        this.isOrtho = true;
        
        // 確保新相機立即可用
        this.orthoCam.updateProjectionMatrix();
        this.orthoCam.updateMatrixWorld(true);
        
        if (this.debugMode) {
          console.log(`切换到正交模式 - FOV: ${currentFov.toFixed(1)}°, 距离: ${currentDistance.toFixed(1)}, 正交尺寸: ${this.orthoSize.toFixed(1)}`);
        }
      }
      
      switchToPerspective() {
        const aspect = window.innerWidth / window.innerHeight;
        
        // 基于当前正交尺寸和当前视线距离计算对应的FOV
        const currentDistance = this.getViewDirectionDistance(this.orthoCam || this.camEntity.getObject3D("camera"));
        
        // 使用当前正交尺寸和距离计算对应的FOV，保持视觉一致性
        const tanHalfFov = this.orthoSize / (2 * currentDistance);
        const fovRadians = 2 * Math.atan(tanHalfFov);
        const calculatedFov = THREE.MathUtils.radToDeg(fovRadians);
        const fov = Math.max(10, Math.min(120, calculatedFov));
        
        // 更新保存的FOV值
        this.savedPerspectiveFov = fov;
        
        this.perspCam = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
        
        this.restoreCameraState(this.perspCam);
        
        this.camEntity.setObject3D("camera", this.perspCam);
        this.sceneEl.camera = this.perspCam;
        
        // 重置速度避免切換後的移動問題
        this.velocity.set(0, 0, 0);
        
        this.label.textContent = "透視模式";
        this.isOrtho = false;
        
        // 確保新相機立即可用
        this.perspCam.updateProjectionMatrix();
        this.perspCam.updateMatrixWorld(true);
        
        if (this.debugMode) {
          console.log(`切换到透视模式 - 正交尺寸: ${this.orthoSize.toFixed(1)}, 距离: ${currentDistance.toFixed(1)}, FOV: ${fov.toFixed(1)}°`);
        }
      }
      
      resetCamera() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          // 暫時禁用look-controls以避免衝突
          this.camEntity.setAttribute('look-controls', 'enabled', false);
          
          // 重置到初始位置和旋轉
          currentCamera.position.copy(this.defaultPosition);
          currentCamera.rotation.copy(this.defaultRotation);
          currentCamera.quaternion.setFromEuler(this.defaultRotation);
          currentCamera.updateMatrix();
          currentCamera.updateMatrixWorld(true);

          // 重置 FOV 和正交尺寸的對應關係
          if (!this.isOrtho) {
            currentCamera.fov = 60;
            this.savedPerspectiveFov = 60;
          } else {
            // 重置正交尺寸
            this.orthoSize = this.defaultOrthoSize;
            const aspect = window.innerWidth / window.innerHeight;
            currentCamera.left = -this.orthoSize * aspect / 2;
            currentCamera.right = this.orthoSize * aspect / 2;
            currentCamera.top = this.orthoSize / 2;
            currentCamera.bottom = -this.orthoSize / 2;
            
            // 同步重置對應的透視FOV
            this.savedPerspectiveFov = 60;
          }
          currentCamera.updateProjectionMatrix();
          
          // 同步A-Frame實體的狀態
          this.camEntity.object3D.position.copy(currentCamera.position);
          this.camEntity.object3D.rotation.copy(currentCamera.rotation);
          this.camEntity.object3D.quaternion.copy(currentCamera.quaternion);
          this.camEntity.object3D.updateMatrix();
          this.camEntity.object3D.updateMatrixWorld(true);
          
          // 同步到A-Frame的attribute系統
          this.camEntity.setAttribute('position', {
            x: this.defaultPosition.x,
            y: this.defaultPosition.y,
            z: this.defaultPosition.z
          });
          this.camEntity.setAttribute('rotation', {
            x: THREE.MathUtils.radToDeg(this.defaultRotation.x),
            y: THREE.MathUtils.radToDeg(this.defaultRotation.y),
            z: THREE.MathUtils.radToDeg(this.defaultRotation.z)
          });
          
          // 重置look-controls的內部狀態
          const lookControls = this.camEntity.components['look-controls'];
          if (lookControls) {
            lookControls.pitchObject.rotation.x = 0;
            lookControls.yawObject.rotation.y = 0;
            lookControls.yawObject.position.copy(this.defaultPosition);
          }
          
          // 重置速度
          this.velocity.set(0, 0, 0);
          
          // 延遲重新啟用look-controls
          setTimeout(() => {
            this.camEntity.setAttribute('look-controls', 'enabled', true);
          }, 50);
          
          this.updateCameraInfo();
          this.updatePositionInfo();
        }
      }
      
      updateOrthoSize() {
        if (!this.isOrtho || !this.orthoCam) return;
        
        // 計算目標尺寸變化
        let targetSizeChange = 0;
        if (this.keys.orthoShrink) targetSizeChange -= this.orthoSizeSpeed;
        if (this.keys.orthoGrow) targetSizeChange += this.orthoSizeSpeed;
        
        // 平滑變化
        this.orthoSizeVelocity = THREE.MathUtils.lerp(this.orthoSizeVelocity, targetSizeChange, 0.3);
        
        // 應用摩擦力
        if (targetSizeChange === 0) {
          this.orthoSizeVelocity *= 0.9;
        }
        
        // 如果變化很小就停止
        if (Math.abs(this.orthoSizeVelocity) < 0.001) {
          this.orthoSizeVelocity = 0;
        }
        
        // 應用尺寸變化
        if (this.orthoSizeVelocity !== 0) {
          this.orthoSize += this.orthoSizeVelocity;
          this.orthoSize = Math.max(0.5, Math.min(50, this.orthoSize));
          
          const aspect = window.innerWidth / window.innerHeight;
          this.orthoCam.left = -this.orthoSize * aspect / 2;
          this.orthoCam.right = this.orthoSize * aspect / 2;
          this.orthoCam.top = this.orthoSize / 2;
          this.orthoCam.bottom = -this.orthoSize / 2;
          this.orthoCam.updateProjectionMatrix();
          
          // 基于当前距离计算对应的FOV，而不是固定距离
          const currentDistance = this.getViewDirectionDistance(this.orthoCam);
          const tanHalfFov = this.orthoSize / (2 * currentDistance);
          const fovRadians = 2 * Math.atan(tanHalfFov);
          const correspondingFov = THREE.MathUtils.radToDeg(fovRadians);
          this.savedPerspectiveFov = Math.max(10, Math.min(120, correspondingFov));
          
          this.updateCameraInfo();
        }
      }
      
      updateCameraInfo() {
        if (this.isOrtho) {
          const currentCamera = this.camEntity.getObject3D("camera");
          const detectedDistance = currentCamera ? this.getViewDirectionDistance(currentCamera) : 0;
          const correspondingFov = this.calculateCorrespondingFov(this.orthoSize);
          
          this.cameraInfo.textContent = `尺寸: ${this.orthoSize.toFixed(1)} | 正交投影`;
          
          // 調試信息
          if (this.debugMode) {
            console.log(`正交模式 - 尺寸: ${this.orthoSize.toFixed(1)}, 檢測距離: ${detectedDistance.toFixed(1)}, 對應FOV: ${correspondingFov.toFixed(1)}°`);
          }
        } else if (this.perspCam) {
          const detectedDistance = this.getViewDirectionDistance(this.perspCam);
          const equivalentOrthoSize = this.calculateOptimalOrthoSize();
          
          this.cameraInfo.textContent = `FOV: ${this.perspCam.fov.toFixed(0)}° | 透視投影`;
          
          // 調試信息  
          if (this.debugMode) {
            console.log(`透視模式 - FOV: ${this.perspCam.fov.toFixed(1)}°, 檢測距離: ${detectedDistance.toFixed(1)}, 等效正交尺寸: ${equivalentOrthoSize.toFixed(1)}`);
          }
        }
      }
      
      updatePositionInfo() {
        // 獲取相機實體和對象
        const cameraEl = this.camEntity;
        const cameraObj = cameraEl.getObject3D('camera');
        
        if (cameraObj) {
          // 獲取位置（來自相機對象的世界位置）
          const worldPos = new THREE.Vector3();
          cameraObj.getWorldPosition(worldPos);
          
          // 獲取旋轉（來自相機對象的世界四元數）
          const worldQuat = new THREE.Quaternion();
          cameraObj.getWorldQuaternion(worldQuat);
          
          // 將四元數轉換為歐拉角
          const euler = new THREE.Euler();
          euler.setFromQuaternion(worldQuat, 'YXZ');
          
          // 更新位置顯示
          this.positionInfo.textContent = 
            `位置: (${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)}, ${worldPos.z.toFixed(1)})`;
          
          // 更新旋轉顯示，第三個值始終為0
          this.rotationInfo.textContent = 
            `旋轉: (${(euler.x * 180 / Math.PI).toFixed(0)}°, ${(euler.y * 180 / Math.PI).toFixed(0)}°, 0°)`;
        }
      }
      
      updateVisualEffects() {
        const grid = document.getElementById("grid");
        if (grid) {
          grid.setAttribute("visible", this.isOrtho);
        }
      }
      
      startPerformanceMonitoring() {
        // FPS计算在animate循环中进行，这里不需要setInterval
        this.lastTime = performance.now();
      }
      
      updatePerformanceInfo() {
        // 每帧更新FPS计算
        const currentTime = performance.now();
        const deltaTime = currentTime - this.lastTime;
        
        // 将帧时间添加到缓冲区
        this.frameTimeBuffer.push(deltaTime);
        if (this.frameTimeBuffer.length > this.bufferSize) {
          this.frameTimeBuffer.shift();
        }
        
        // 每30帧更新一次显示（约0.5秒）
        if (this.frameCount % 30 === 0 && this.frameTimeBuffer.length > 10) {
          // 计算平均帧时间
          const avgFrameTime = this.frameTimeBuffer.reduce((sum, time) => sum + time, 0) / this.frameTimeBuffer.length;
          this.fps = Math.round(1000 / avgFrameTime);
          
          const objectCount = this.sceneEl.querySelectorAll('a-entity, a-sphere, a-box, a-cylinder, a-torus, a-plane').length;
          this.performanceInfo.textContent = `FPS: ${this.fps} | 物件: ${objectCount}`;
        }
        
        this.lastTime = currentTime;
      }
      
      handleResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const threeCam = this.camEntity.getObject3D("camera");
        
        if (!threeCam) return;
        
        if (threeCam.isPerspectiveCamera) {
          threeCam.aspect = aspect;
          threeCam.updateProjectionMatrix();
        } else if (threeCam.isOrthographicCamera) {
          threeCam.left = -this.orthoSize * aspect / 2;
          threeCam.right = this.orthoSize * aspect / 2;
          threeCam.top = this.orthoSize / 2;
          threeCam.bottom = -this.orthoSize / 2;
          threeCam.updateProjectionMatrix();
        }
      }
    }
    
    // 初始化控制器
    document.addEventListener('DOMContentLoaded', () => {
      new EnhancedCameraController();
    });
  </script>
</body>
</html>