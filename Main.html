<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced Camera Toggle VR Scene</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { 
      margin: 0; 
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    }
    
    .camera-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 12px;
      color: white;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .control-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .control-row:last-child {
      margin-bottom: 0;
    }
    
    .toggle-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .toggle-btn:active {
      transform: translateY(0);
    }
    
    .mode-label {
      font-weight: bold;
      font-size: 16px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }
    
    .camera-info {
      font-size: 12px;
      color: #b0b0b0;
      margin-top: 8px;
      font-family: 'Courier New', monospace;
    }
    
    .position-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .rotation-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .instructions {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.85);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      max-width: 280px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .instructions h4 {
      margin: 0 0 10px 0;
      color: #00ff88;
      font-size: 14px;
    }
    
    .control-group {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    
    .performance-info {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 6px;
      color: #00ff88;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      border: 1px solid rgba(0, 255, 136, 0.2);
    }
  </style>
</head>
<body>
  <div class="camera-controls">
    <div class="control-row">
      <button id="toggleBtn" class="toggle-btn">åˆ‡æ›ç›¸æ©Ÿ</button>
      <span id="modeLabel" class="mode-label">é€è¦–æ¨¡å¼</span>
    </div>
    <div id="cameraInfo" class="camera-info">FOV: 60Â° | é€è¦–æŠ•å½±</div>
    <div id="positionInfo" class="position-info">ä½ç½®: (0.0, 1.6, 3.0)</div>
    <div id="rotationInfo" class="rotation-info">æ—‹è½‰: (0Â°, 0Â°, 0Â°)</div>
  </div>
  
  <div class="performance-info" id="performanceInfo">
    FPS: -- | ç‰©ä»¶: --
  </div>
  
  <div class="instructions">
    <h4>ğŸ® æ§åˆ¶èªªæ˜</h4>
    <div class="control-group">
      <span class="key">æ»‘é¼ æ‹–æ›³</span> æ—‹è½‰è¦–è§’<br>
      <span class="key">WASD</span> / <span class="key">æ–¹å‘éµ</span> ç§»å‹•ç›¸æ©Ÿ
    </div>
    <div class="control-group">
      <span class="key">ç©ºç™½éµ</span> åˆ‡æ›ç›¸æ©Ÿæ¨¡å¼<br>
      <span class="key">æ»¾è¼ª</span> ç¸®æ”¾ (é€è¦–æ¨¡å¼)
    </div>
    <div class="control-group">
      <span class="key">WS</span> èª¿æ•´æ­£äº¤å°ºå¯¸ (æ­£äº¤æ¨¡å¼)<br>
      <span class="key">R</span> é‡ç½®ç›¸æ©Ÿä½ç½®
    </div>
  </div>

  <a-scene id="mainScene" background="color: #0f0f23" fog="type: exponential; color: #0f0f23; density: 0.02">
    <a-entity id="cameraRig" position="0 1.6 3">
      <a-camera id="cam" look-controls wasd-controls="enabled: false"></a-camera>
    </a-entity>
    
    <!-- å‰µå»ºä¸€å€‹æ›´è±å¯Œçš„3Då ´æ™¯ -->
    
    <!-- ä¸­å¤®æ—‹è½‰çƒé«” -->
    <a-sphere position="0 2 0" radius="0.8" color="#ff6b6b" 
              material="metalness: 0.7; roughness: 0.3"
              animation="property: rotation; to: 0 360 0; loop: true; dur: 4000"
              animation__bounce="property: position; to: 0 3 0; dir: alternate; loop: true; dur: 3000; easing: easeInOutSine"></a-sphere>
    
    <!-- å·¦å´è·³èºæ–¹å¡Š -->
    <a-box position="-4 1 0" rotation="0 45 0" color="#4ecdc4" 
           material="metalness: 0.5; roughness: 0.4"
           animation="property: position; to: -4 3 0; dir: alternate; loop: true; dur: 2000; easing: easeInOutBounce"
           animation__rotate="property: rotation; to: 360 45 360; loop: true; dur: 5000"></a-box>
    

    <!-- å¾Œæ–¹æ—‹è½‰ç’° -->
    <a-torus position="0 2 -5" color="#96ceb4" radius="1.5" radius-tubular="0.2"
             material="metalness: 0.8; roughness: 0.1"
             animation="property: rotation; to: 360 360 0; loop: true; dur: 6000"></a-torus>
    
    <!-- åœ°æ¿å’Œç‰†å£ -->
    <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" 
             color="#2c3e50" material="metalness: 0.1; roughness: 0.9"></a-plane>
    
    <!-- èƒŒæ™¯ç‰† -->
    <a-plane position="0 5 -10" rotation="0 0 0" width="20" height="10" 
             color="#34495e" material="opacity: 0.7; transparent: true"></a-plane>
    
    <!-- ç¶²æ ¼å¹«åŠ©ç·š -->
    <a-entity id="grid" visible="false">
      <a-plane position="0 0.01 0" rotation="-90 0 0" width="20" height="20" 
               material="color: #555; opacity: 0.3; transparent: true" wireframe="true"></a-plane>
      <!-- åº§æ¨™è»¸æŒ‡ç¤ºå™¨ -->
      <a-box position="1 0.05 0" width="2" height="0.1" depth="0.1" color="#ff0000"></a-box>
      <a-box position="0 1 0" width="0.1" height="2" depth="0.1" color="#00ff00"></a-box>
      <a-box position="0 0.05 1" width="0.1" height="0.1" depth="2" color="#0000ff"></a-box>
    </a-entity>
    
    <!-- å¢å¼·å…‰æºç³»çµ± -->
    <a-light type="ambient" color="#404040" intensity="0.3"></a-light>
    <a-light type="point" position="3 5 3" color="#ffffff" intensity="0.8" 
             animation="property: position; to: -3 5 -3; dir: alternate; loop: true; dur: 10000"></a-light>
    <a-light type="point" position="-3 5 3" color="#ff6b6b" intensity="0.6"
             animation="property: position; to: 3 5 -3; dir: alternate; loop: true; dur: 8000"></a-light>
    <a-light type="directional" position="0 10 0" color="#87ceeb" intensity="0.4"></a-light>
  </a-scene>

  <script>
    class EnhancedCameraController {
      constructor() {
        this.sceneEl = document.querySelector("a-scene");
        this.camEntity = document.getElementById("cam");
        this.cameraRig = document.getElementById("cameraRig");
        this.label = document.getElementById("modeLabel");
        this.toggleBtn = document.getElementById("toggleBtn");
        this.cameraInfo = document.getElementById("cameraInfo");
        this.positionInfo = document.getElementById("positionInfo");
        this.rotationInfo = document.getElementById("rotationInfo");
        this.performanceInfo = document.getElementById("performanceInfo");
        
        this.isOrtho = false;
        this.orthoCam = null;
        this.perspCam = null;
        this.orthoSize = 5;
        
        // ç›¸æ©Ÿç‹€æ…‹ä¿å­˜
        this.savedState = {
          position: new THREE.Vector3(0, 1.6, 3),
          rotation: new THREE.Euler(),
          quaternion: new THREE.Quaternion()
        };
        
        // ç§»å‹•æ§åˆ¶
        this.keys = {};
        this.moveSpeed = 0.1; // çµ±ä¸€çš„ç§»å‹•é€Ÿåº¦
        this.smoothing = 0.1;
        this.velocity = new THREE.Vector3();
        this.acceleration = 0.02;
        this.friction = 0.9;
        
        // æ»‘é¼ ç‹€æ…‹
        this.isMouseDown = false;
        this.isTouchDown = false;
        
        // æ€§èƒ½ç›£æ§
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
        
        // é»˜èªç›¸æ©Ÿä½ç½®
        this.defaultPosition = new THREE.Vector3(0, 1.6, 3);
        this.defaultRotation = new THREE.Euler(0, 0, 0);
        
        this.init();
      }
      
      init() {
        this.sceneEl.addEventListener("loaded", () => {
          // ç«‹å³æ›¿æ›é»˜èªç›¸æ©Ÿï¼Œç¢ºä¿å¾ä¸€é–‹å§‹å°±ä½¿ç”¨çµ±ä¸€çš„ç›¸æ©Ÿç³»çµ±
          const aspect = window.innerWidth / window.innerHeight;
          this.perspCam = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
          
          // è¨­ç½®åˆå§‹ä½ç½®å’Œæ—‹è½‰
          this.perspCam.position.copy(this.defaultPosition);
          this.perspCam.rotation.copy(this.defaultRotation);
          this.perspCam.quaternion.setFromEuler(this.defaultRotation);
          this.perspCam.updateMatrix();
          this.perspCam.updateMatrixWorld(true);
          this.perspCam.updateProjectionMatrix();
          
          // åŒæ­¥A-Frameå¯¦é«”ç‹€æ…‹
          this.camEntity.object3D.position.copy(this.perspCam.position);
          this.camEntity.object3D.rotation.copy(this.perspCam.rotation);
          this.camEntity.object3D.quaternion.copy(this.perspCam.quaternion);
          this.camEntity.object3D.updateMatrix();
          this.camEntity.object3D.updateMatrixWorld(true);
          
          // æ›¿æ›é»˜èªç›¸æ©Ÿ
          this.camEntity.setObject3D("camera", this.perspCam);
          this.sceneEl.camera = this.perspCam;
          
          this.updateCameraInfo();
          this.setupEventListeners();
          this.startPerformanceMonitoring();
          this.animate();
        });
      }
      
      setupEventListeners() {
        // æŒ‰éˆ•åˆ‡æ›
        this.toggleBtn.addEventListener("click", () => this.toggleCamera());
        
        // éµç›¤æ§åˆ¶
        document.addEventListener("keydown", (e) => this.handleKeyDown(e));
        document.addEventListener("keyup", (e) => this.handleKeyUp(e));
        
        // æ»¾è¼ªç¸®æ”¾
        this.sceneEl.addEventListener("wheel", (e) => this.handleWheel(e), { passive: false });
        
        // è¦–çª—å¤§å°è®ŠåŒ–
        window.addEventListener("resize", () => this.handleResize());
        
        // ä½¿ç”¨ setInterval å®šæœŸæ›´æ–°æ—‹è½‰ä¿¡æ¯
        setInterval(() => {
          this.updatePositionInfo();
        }, 50); // æ¯50æ¯«ç§’æ›´æ–°ä¸€æ¬¡ï¼ˆ20 FPSï¼‰
      }
      
      handleKeyDown(e) {
        if (e.repeat) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            this.toggleCamera();
            break;
          case 'KeyR':
            e.preventDefault();
            this.resetCamera();
            break;
          case 'KeyW':
            if (this.isOrtho) {
              e.preventDefault();
              this.adjustOrthoSize(0.9);
            } else {
              this.keys.forward = true;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              e.preventDefault();
              this.adjustOrthoSize(1.1);
            } else {
              this.keys.backward = true;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = true;
            break;
          case 'ArrowDown':
            this.keys.backward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = true;
            break;
        }
      }
      
      handleKeyUp(e) {
        switch(e.code) {
          case 'KeyW':
            if (!this.isOrtho) {
              this.keys.forward = false;
            }
            break;
          case 'KeyS':
            if (!this.isOrtho) {
              this.keys.backward = false;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = false;
            break;
          case 'ArrowDown':
            this.keys.backward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = false;
            break;
        }
      }
      
      handleWheel(e) {
        if (!this.isOrtho && this.perspCam) {
          e.preventDefault();
          const currentFov = this.perspCam.fov;
          const delta = e.deltaY * 0.1;
          const newFov = Math.max(10, Math.min(120, currentFov + delta));
          
          this.perspCam.fov = newFov;
          this.perspCam.updateProjectionMatrix();
          this.updateCameraInfo();
        }
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        
        // æ›´æ–°ç§»å‹•
        this.updateMovement();
        
        // æ›´æ–°æ€§èƒ½ä¿¡æ¯
        this.updatePerformanceInfo();
        
        this.frameCount++;
      }
      
      updateMovement() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return;
        
        // è¨ˆç®—ç›®æ¨™ç§»å‹•æ–¹å‘
        const targetVelocity = new THREE.Vector3();
        
        if (this.keys.forward) targetVelocity.z -= 1;
        if (this.keys.backward) targetVelocity.z += 1;
        if (this.keys.left) targetVelocity.x -= 1;
        if (this.keys.right) targetVelocity.x += 1;
        
        // æ­£è¦åŒ–ç§»å‹•å‘é‡ä¸¦æ‡‰ç”¨çµ±ä¸€é€Ÿåº¦
        if (targetVelocity.length() > 0) {
          targetVelocity.normalize();
          targetVelocity.multiplyScalar(this.moveSpeed);
        }
        
        // å¹³æ»‘ç§»å‹•
        this.velocity.lerp(targetVelocity, 0.3);
        
        // æ‡‰ç”¨æ‘©æ“¦åŠ›
        if (targetVelocity.length() === 0) {
          this.velocity.multiplyScalar(this.friction);
        }
        
        // å¦‚æœé€Ÿåº¦å¾ˆå°å°±åœæ­¢
        if (this.velocity.length() < 0.001) {
          this.velocity.set(0, 0, 0);
        }
        
        // æ‡‰ç”¨ç§»å‹•åˆ°ç›¸æ©Ÿ
        if (this.velocity.length() > 0) {
          const moveVector = this.velocity.clone();
          // ä½¿ç”¨ç›¸æ©Ÿçš„å››å…ƒæ•¸ä¾†è®Šæ›ç§»å‹•æ–¹å‘
          moveVector.applyQuaternion(currentCamera.quaternion);
          
          // ç›´æ¥æ›´æ–°ç›¸æ©Ÿä½ç½®
          currentCamera.position.add(moveVector);
          
          // åŒæ­¥A-Frameå¯¦é«”ä½ç½®
          this.camEntity.object3D.position.copy(currentCamera.position);
          this.camEntity.setAttribute('position', {
            x: currentCamera.position.x,
            y: currentCamera.position.y,
            z: currentCamera.position.z
          });
        }
      }
      
      saveCameraState() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          currentCamera.updateMatrixWorld(true);
          this.savedState.position.copy(currentCamera.position);
          this.savedState.rotation.copy(currentCamera.rotation);
          this.savedState.quaternion.copy(currentCamera.quaternion);
        }
      }
      
      restoreCameraState(newCamera) {
        if (newCamera) {
          newCamera.position.copy(this.savedState.position);
          newCamera.rotation.copy(this.savedState.rotation);
          newCamera.quaternion.copy(this.savedState.quaternion);
          
          // ç¢ºä¿çŸ©é™£ç‹€æ…‹å®Œå…¨åŒæ­¥
          newCamera.updateMatrix();
          newCamera.updateMatrixWorld(true);
          newCamera.updateProjectionMatrix();
          
          // åŒæ­¥A-Frameå¯¦é«”çš„è®Šæ›ç‹€æ…‹
          const cameraEl = this.camEntity;
          cameraEl.object3D.position.copy(newCamera.position);
          cameraEl.object3D.rotation.copy(newCamera.rotation);
          cameraEl.object3D.quaternion.copy(newCamera.quaternion);
          cameraEl.object3D.updateMatrix();
          cameraEl.object3D.updateMatrixWorld(true);
          
          // åŒæ­¥åˆ°A-Frameçš„attributeç³»çµ±
          cameraEl.setAttribute('position', {
            x: newCamera.position.x,
            y: newCamera.position.y,
            z: newCamera.position.z
          });
          cameraEl.setAttribute('rotation', {
            x: THREE.MathUtils.radToDeg(newCamera.rotation.x),
            y: THREE.MathUtils.radToDeg(newCamera.rotation.y),
            z: THREE.MathUtils.radToDeg(newCamera.rotation.z)
          });
        }
      }
      
      toggleCamera() {
        this.saveCameraState();
        
        if (!this.isOrtho) {
          this.switchToOrthographic();
        } else {
          this.switchToPerspective();
        }
        
        this.updateCameraInfo();
        this.updateVisualEffects();
      }
      
      switchToOrthographic() {
        const aspect = window.innerWidth / window.innerHeight;
        
        this.orthoCam = new THREE.OrthographicCamera(
          -this.orthoSize * aspect / 2, 
          this.orthoSize * aspect / 2,
          this.orthoSize / 2, 
          -this.orthoSize / 2,
          0.1, 
          1000
        );
        
        this.restoreCameraState(this.orthoCam);
        
        this.camEntity.setObject3D("camera", this.orthoCam);
        this.sceneEl.camera = this.orthoCam;
        
        // é‡ç½®é€Ÿåº¦é¿å…åˆ‡æ›å¾Œçš„ç§»å‹•å•é¡Œ
        this.velocity.set(0, 0, 0);
        
        this.label.textContent = "æ­£äº¤æ¨¡å¼";
        this.isOrtho = true;
        
        // ç¢ºä¿æ–°ç›¸æ©Ÿç«‹å³å¯ç”¨
        this.orthoCam.updateProjectionMatrix();
        this.orthoCam.updateMatrixWorld(true);
      }
      
      switchToPerspective() {
        const aspect = window.innerWidth / window.innerHeight;
        const fov = this.perspCam ? this.perspCam.fov : 60;
        
        this.perspCam = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
        
        this.restoreCameraState(this.perspCam);
        
        this.camEntity.setObject3D("camera", this.perspCam);
        this.sceneEl.camera = this.perspCam;
        
        // é‡ç½®é€Ÿåº¦é¿å…åˆ‡æ›å¾Œçš„ç§»å‹•å•é¡Œ
        this.velocity.set(0, 0, 0);
        
        this.label.textContent = "é€è¦–æ¨¡å¼";
        this.isOrtho = false;
        
        // ç¢ºä¿æ–°ç›¸æ©Ÿç«‹å³å¯ç”¨
        this.perspCam.updateProjectionMatrix();
        this.perspCam.updateMatrixWorld(true);
      }
      
      resetCamera() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          currentCamera.position.copy(this.defaultPosition);
          currentCamera.rotation.copy(this.defaultRotation);
          currentCamera.quaternion.setFromEuler(this.defaultRotation);
          currentCamera.updateMatrix();
          currentCamera.updateMatrixWorld(true);
          this.updatePositionInfo();
        }
      }
      
      adjustOrthoSize(factor) {
        if (!this.isOrtho || !this.orthoCam) return;
        
        this.orthoSize *= factor;
        this.orthoSize = Math.max(0.5, Math.min(50, this.orthoSize));
        
        const aspect = window.innerWidth / window.innerHeight;
        this.orthoCam.left = -this.orthoSize * aspect / 2;
        this.orthoCam.right = this.orthoSize * aspect / 2;
        this.orthoCam.top = this.orthoSize / 2;
        this.orthoCam.bottom = -this.orthoSize / 2;
        this.orthoCam.updateProjectionMatrix();
        
        this.updateCameraInfo();
      }
      
      updateCameraInfo() {
        if (this.isOrtho) {
          this.cameraInfo.textContent = `å°ºå¯¸: ${this.orthoSize.toFixed(1)} | æ­£äº¤æŠ•å½±`;
        } else if (this.perspCam) {
          this.cameraInfo.textContent = `FOV: ${this.perspCam.fov.toFixed(0)}Â° | é€è¦–æŠ•å½±`;
        }
      }
      
      updatePositionInfo() {
        // ç²å–ç›¸æ©Ÿå¯¦é«”å’Œå°è±¡
        const cameraEl = this.camEntity;
        const cameraObj = cameraEl.getObject3D('camera');
        
        if (cameraObj) {
          // ç²å–ä½ç½®ï¼ˆä¾†è‡ªç›¸æ©Ÿå°è±¡çš„ä¸–ç•Œä½ç½®ï¼‰
          const worldPos = new THREE.Vector3();
          cameraObj.getWorldPosition(worldPos);
          
          // ç²å–æ—‹è½‰ï¼ˆä¾†è‡ªç›¸æ©Ÿå°è±¡çš„ä¸–ç•Œå››å…ƒæ•¸ï¼‰
          const worldQuat = new THREE.Quaternion();
          cameraObj.getWorldQuaternion(worldQuat);
          
          // å°‡å››å…ƒæ•¸è½‰æ›ç‚ºæ­æ‹‰è§’
          const euler = new THREE.Euler();
          euler.setFromQuaternion(worldQuat, 'YXZ');
          
          // æ›´æ–°ä½ç½®é¡¯ç¤º
          this.positionInfo.textContent = 
            `ä½ç½®: (${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)}, ${worldPos.z.toFixed(1)})`;
          
          // æ›´æ–°æ—‹è½‰é¡¯ç¤ºï¼Œç¬¬ä¸‰å€‹å€¼å§‹çµ‚ç‚º0
          this.rotationInfo.textContent = 
            `æ—‹è½‰: (${(euler.x * 180 / Math.PI).toFixed(0)}Â°, ${(euler.y * 180 / Math.PI).toFixed(0)}Â°, 0Â°)`;
        }
      }
      
      updateVisualEffects() {
        const grid = document.getElementById("grid");
        grid.setAttribute("visible", this.isOrtho);
      }
      
      startPerformanceMonitoring() {
        setInterval(() => {
          const now = performance.now();
          this.fps = Math.round(1000 / (now - this.lastTime));
          this.lastTime = now;
        }, 1000);
      }
      
      updatePerformanceInfo() {
        if (this.frameCount % 30 === 0) {
          const objectCount = this.sceneEl.querySelectorAll('a-entity, a-sphere, a-box, a-cylinder, a-torus, a-plane').length;
          this.performanceInfo.textContent = `FPS: ${this.fps} | ç‰©ä»¶: ${objectCount}`;
        }
      }
      
      handleResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const threeCam = this.camEntity.getObject3D("camera");
        
        if (!threeCam) return;
        
        if (threeCam.isPerspectiveCamera) {
          threeCam.aspect = aspect;
          threeCam.updateProjectionMatrix();
        } else if (threeCam.isOrthographicCamera) {
          threeCam.left = -this.orthoSize * aspect / 2;
          threeCam.right = this.orthoSize * aspect / 2;
          threeCam.top = this.orthoSize / 2;
          threeCam.bottom = -this.orthoSize / 2;
          threeCam.updateProjectionMatrix();
        }
      }
    }
    
    // åˆå§‹åŒ–æ§åˆ¶å™¨
    document.addEventListener('DOMContentLoaded', () => {
      new EnhancedCameraController();
    });
  </script>
</body>
</html>