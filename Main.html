<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced Camera Toggle VR Scene</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { 
      margin: 0; 
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    }
    
    .camera-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 12px;
      color: white;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .control-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .control-row:last-child {
      margin-bottom: 0;
    }
    
    .toggle-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .toggle-btn:active {
      transform: translateY(0);
    }
    
    .mode-label {
      font-weight: bold;
      font-size: 16px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }
    
    .camera-info {
      font-size: 12px;
      color: #b0b0b0;
      margin-top: 8px;
      font-family: 'Courier New', monospace;
    }
    
    .position-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .rotation-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .instructions {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.85);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      max-width: 280px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .instructions h4 {
      margin: 0 0 10px 0;
      color: #00ff88;
      font-size: 14px;
    }
    
    .control-group {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    
    .performance-info {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 6px;
      color: #00ff88;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      border: 1px solid rgba(0, 255, 136, 0.2);
    }
    
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      pointer-events: none;
      width: 24px;
      height: 24px;
    }
    
    .crosshair-circle {
      width: 100%;
      height: 100%;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      background: transparent;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1);
      animation: crosshair-pulse 2s ease-in-out infinite alternate;
    }
    
    @keyframes crosshair-pulse {
      0% {
        border-color: rgba(255, 255, 255, 0.6);
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.2), inset 0 0 8px rgba(255, 255, 255, 0.05);
      }
      100% {
        border-color: rgba(255, 255, 255, 1);
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.5), inset 0 0 15px rgba(255, 255, 255, 0.2);
      }
    }
  </style>
</head>
<body>
  <div class="camera-controls">
    <div class="control-row">
      <button id="toggleBtn" class="toggle-btn">åˆ‡æ›ç›¸æ©Ÿ</button>
      <span id="modeLabel" class="mode-label">é€è¦–æ¨¡å¼</span>
    </div>
    <div id="cameraInfo" class="camera-info">FOV: 60Â° | é€è¦–æŠ•å½±</div>
    <div id="positionInfo" class="position-info">ä½ç½®: (0.0, 1.6, 3.0)</div>
    <div id="rotationInfo" class="rotation-info">æ—‹è½‰: (0Â°, 0Â°, 0Â°)</div>
  </div>
  
  <div class="performance-info" id="performanceInfo">
    FPS: -- | ç‰©ä»¶: --
  </div>
  
  <!-- è¦–ç·šä¸­å¿ƒæŒ‡ç¤ºå™¨ -->
  <div class="crosshair" id="crosshair">
    <div class="crosshair-circle"></div>
  </div>
  
  <div class="instructions">
    <h4>ğŸ® æ§åˆ¶èªªæ˜</h4>
    <div class="control-group">
      <span class="key">æ»‘é¼ æ‹–æ›³</span> æ—‹è½‰è¦–è§’<br>
      <span class="key">WASD</span> / <span class="key">æ–¹å‘éµ</span> ç§»å‹•ç›¸æ©Ÿ
    </div>
    <div class="control-group">
      <span class="key">ç©ºç™½éµ</span> åˆ‡æ›ç›¸æ©Ÿæ¨¡å¼<br>
      <span class="key">æ»¾è¼ª</span> ç¸®æ”¾ (é€è¦–æ¨¡å¼)
    </div>
    <div class="control-group">
      <span class="key">WS</span> èª¿æ•´æ­£äº¤å°ºå¯¸ (æ­£äº¤æ¨¡å¼)<br>
      <span class="key">R</span> é‡ç½®ç›¸æ©Ÿä½ç½®<br>
      <span class="key">C</span> åˆ‡æ›è¦–ç·šæŒ‡ç¤ºå™¨
    </div>
  </div>

  <a-scene id="mainScene" background="color: #0f0f23" fog="type: exponential; color: #0f0f23; density: 0.02">
    <a-entity id="cameraRig" position="0 1.6 3">
      <a-camera id="cam" look-controls wasd-controls="enabled: false"></a-camera>
    </a-entity>
    
    <!-- å‰µå»ºä¸€å€‹æ›´è±å¯Œçš„3Då ´æ™¯ -->
    
    <!-- å³å´éœæ…‹æ–¹å¡Šï¼ˆç”¨æ–¼æ¸¬è©¦è¦–è¦ºåŒ¹é…ï¼‰ -->
    <a-box position="4 1.6 0" rotation="0 0 0" color="#e74c3c" 
           material="metalness: 0.3; roughness: 0.6"></a-box>
    
    <!-- æ­£å‰æ–¹éœæ…‹çƒé«”ï¼ˆä¸»è¦æ¸¬è©¦ç›®æ¨™ï¼‰ -->
    <a-sphere position="0 1.6 -3" radius="0.5" color="#f39c12" 
              material="metalness: 0.4; roughness: 0.5"></a-sphere>
    
    <!-- å·¦å‰æ–¹éœæ…‹åœ“ç’° -->
    <a-torus position="-2 1.6 -4" color="#9b59b6" radius="0.6" radius-tubular="0.15"
             material="metalness: 0.6; roughness: 0.3"></a-torus>
    
    <!-- åœ°æ¿å’Œç‰†å£ -->
    <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" 
             color="#2c3e50" material="metalness: 0.1; roughness: 0.9"></a-plane>
    
    <!-- èƒŒæ™¯ç‰† -->
    <a-plane position="0 5 -10" rotation="0 0 0" width="20" height="10" 
             color="#34495e" material="opacity: 0.7; transparent: true"></a-plane>
    
    <!-- å¢å¼·å…‰æºç³»çµ± -->
    <a-light type="ambient" color="#404040" intensity="0.3"></a-light>
    <a-light type="point" position="3 5 3" color="#ffffff" intensity="0.8" 
             animation="property: position; to: -3 5 -3; dir: alternate; loop: true; dur: 10000"></a-light>
    <a-light type="point" position="-3 5 3" color="#ff6b6b" intensity="0.6"
             animation="property: position; to: 3 5 -3; dir: alternate; loop: true; dur: 8000"></a-light>
    <a-light type="directional" position="0 10 0" color="#87ceeb" intensity="0.4"></a-light>
  </a-scene>

  <script>
    class EnhancedCameraController {
      constructor() {
        this.sceneEl = document.querySelector("a-scene");
        this.camEntity = document.getElementById("cam");
        this.cameraRig = document.getElementById("cameraRig");
        this.label = document.getElementById("modeLabel");
        this.toggleBtn = document.getElementById("toggleBtn");
        this.cameraInfo = document.getElementById("cameraInfo");
        this.positionInfo = document.getElementById("positionInfo");
        this.rotationInfo = document.getElementById("rotationInfo");
        this.performanceInfo = document.getElementById("performanceInfo");
        this.crosshair = document.getElementById("crosshair");
        
        this.isOrtho = false;
        this.orthoCam = null;
        this.perspCam = null;
        this.orthoSize = 5;
        
        // ç›¸æ©Ÿç‹€æ…‹ä¿å­˜
        this.savedState = {
          position: new THREE.Vector3(0, 1.6, 3),
          rotation: new THREE.Euler(),
          quaternion: new THREE.Quaternion()
        };
        
        // ä¿å­˜é€è¦–ç›¸æ©Ÿçš„FOVå€¼
        this.savedPerspectiveFov = 60;
        
        // ç§»å‹•æ§åˆ¶
        this.keys = {};
        this.moveSpeed = 0.1; // çµ±ä¸€çš„ç§»å‹•é€Ÿåº¦
        this.smoothing = 0.1;
        this.velocity = new THREE.Vector3();
        this.acceleration = 0.02;
        this.friction = 0.9;
        
        // æ­£äº¤å°ºå¯¸æ§åˆ¶
        this.targetOrthoSize = 5;
        this.orthoSizeVelocity = 0;
        this.orthoSizeSpeed = 0.15;
        
        // æ»‘é¼ ç‹€æ…‹
        this.isMouseDown = false;
        this.isTouchDown = false;
        
        // æ€§èƒ½ç›£æ§
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
        this.frameTimeBuffer = [];
        this.bufferSize = 60; // ä½¿ç”¨60å¸§æ¥è®¡ç®—å¹³å‡FPS
        
        // é»˜èªç›¸æ©Ÿä½ç½®
        this.defaultPosition = new THREE.Vector3(0, 1.6, 3);
        this.defaultRotation = new THREE.Euler(0, 0, 0);
        
        // è¦–ç·šä¸­å¿ƒæŒ‡ç¤ºå™¨ç‹€æ…‹
        this.crosshairVisible = true;
        
        // è¦–è¦ºåŒ¹é…ï¼šåŸºæ–¼è¦–ç·šæ–¹å‘çš„è·é›¢æª¢æ¸¬
        this.defaultOrthoSize = 21.9; // é»˜èªæ­£äº¤å°ºå¯¸
        
        // å½“å‰è§†çº¿è·ç¦»ç¼“å­˜ï¼Œç”¨äºä¿æŒè§†è§‰ä¸€è‡´æ€§
        this.currentViewDistance = null;
        
        // èª¿è©¦æ¨¡å¼ï¼ˆè¨­ç‚º true å¯åœ¨æ§åˆ¶å°çœ‹åˆ°è©³ç´°ä¿¡æ¯ï¼‰
        this.debugMode = false;
        
        this.init();
      }
      
      init() {
        this.sceneEl.addEventListener("loaded", () => {
          // ç«‹å³æ›¿æ›é»˜èªç›¸æ©Ÿï¼Œç¢ºä¿å¾ä¸€é–‹å§‹å°±ä½¿ç”¨çµ±ä¸€çš„ç›¸æ©Ÿç³»çµ±
          const aspect = window.innerWidth / window.innerHeight;
          this.perspCam = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
          
          // è¨­ç½®åˆå§‹ä½ç½®å’Œæ—‹è½‰
          this.perspCam.position.copy(this.defaultPosition);
          this.perspCam.rotation.copy(this.defaultRotation);
          this.perspCam.quaternion.setFromEuler(this.defaultRotation);
          this.perspCam.updateMatrix();
          this.perspCam.updateMatrixWorld(true);
          this.perspCam.updateProjectionMatrix();
          
          // åŒæ­¥A-Frameå¯¦é«”ç‹€æ…‹
          this.camEntity.object3D.position.copy(this.perspCam.position);
          this.camEntity.object3D.rotation.copy(this.perspCam.rotation);
          this.camEntity.object3D.quaternion.copy(this.perspCam.quaternion);
          this.camEntity.object3D.updateMatrix();
          this.camEntity.object3D.updateMatrixWorld(true);
          
          // æ›¿æ›é»˜èªç›¸æ©Ÿ
          this.camEntity.setObject3D("camera", this.perspCam);
          this.sceneEl.camera = this.perspCam;
          
          this.updateCameraInfo();
          this.setupEventListeners();
          this.startPerformanceMonitoring();
          this.animate();
        });
      }
      
      setupEventListeners() {
        // æŒ‰éˆ•åˆ‡æ›
        this.toggleBtn.addEventListener("click", () => this.toggleCamera());
        
        // éµç›¤æ§åˆ¶
        document.addEventListener("keydown", (e) => this.handleKeyDown(e));
        document.addEventListener("keyup", (e) => this.handleKeyUp(e));
        
        // æ»¾è¼ªç¸®æ”¾
        this.sceneEl.addEventListener("wheel", (e) => this.handleWheel(e), { passive: false });
        
        // è¦–çª—å¤§å°è®ŠåŒ–
        window.addEventListener("resize", () => this.handleResize());
        
        // ä½¿ç”¨ setInterval å®šæœŸæ›´æ–°æ—‹è½‰ä¿¡æ¯
        setInterval(() => {
          this.updatePositionInfo();
        }, 50); // æ¯50æ¯«ç§’æ›´æ–°ä¸€æ¬¡ï¼ˆ20 FPSï¼‰
      }
      
      handleKeyDown(e) {
        if (e.repeat) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            this.toggleCamera();
            break;
          case 'KeyR':
            e.preventDefault();
            this.resetCamera();
            break;
          case 'KeyC':
            e.preventDefault();
            this.toggleCrosshair();
            break;
          case 'KeyG':
            e.preventDefault();
            this.debugMode = !this.debugMode;
            console.log(`èª¿è©¦æ¨¡å¼: ${this.debugMode ? 'é–‹å•Ÿ' : 'é—œé–‰'}`);
            break;
          case 'KeyW':
            if (this.isOrtho) {
              e.preventDefault();
              this.keys.orthoShrink = true;
            } else {
              this.keys.forward = true;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              e.preventDefault();
              this.keys.orthoGrow = true;
            } else {
              this.keys.backward = true;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = true;
            break;
          case 'ArrowDown':
            this.keys.backward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = true;
            break;
        }
      }
      
      handleKeyUp(e) {
        switch(e.code) {
          case 'KeyW':
            if (this.isOrtho) {
              this.keys.orthoShrink = false;
            } else {
              this.keys.forward = false;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              this.keys.orthoGrow = false;
            } else {
              this.keys.backward = false;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = false;
            break;
          case 'ArrowDown':
            this.keys.backward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = false;
            break;
        }
      }
      
      handleWheel(e) {
        if (!this.isOrtho && this.perspCam) {
          e.preventDefault();
          const currentFov = this.perspCam.fov;
          const delta = e.deltaY * 0.1;
          const newFov = Math.max(10, Math.min(120, currentFov + delta));
          
          this.perspCam.fov = newFov;
          this.savedPerspectiveFov = newFov; // åŒæ­¥ä¿å­˜FOVå€¼
          this.perspCam.updateProjectionMatrix();
          this.updateCameraInfo();
        }
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        
        // æ›´æ–°ç§»å‹•
        this.updateMovement();
        
        // æ›´æ–°æ­£äº¤å°ºå¯¸ï¼ˆå¦‚æœåœ¨æ­£äº¤æ¨¡å¼ï¼‰
        this.updateOrthoSize();
        
        // æ›´æ–°æ€§èƒ½ä¿¡æ¯
        this.updatePerformanceInfo();
        
        this.frameCount++;
      }
      
      updateMovement() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return;
        
        // è¨ˆç®—ç›®æ¨™ç§»å‹•æ–¹å‘
        const targetVelocity = new THREE.Vector3();
        
        if (this.keys.forward) targetVelocity.z -= 1;
        if (this.keys.backward) targetVelocity.z += 1;
        if (this.keys.left) targetVelocity.x -= 1;
        if (this.keys.right) targetVelocity.x += 1;
        
        // æ­£è¦åŒ–ç§»å‹•å‘é‡ä¸¦æ‡‰ç”¨çµ±ä¸€é€Ÿåº¦
        if (targetVelocity.length() > 0) {
          targetVelocity.normalize();
          targetVelocity.multiplyScalar(this.moveSpeed);
        }
        
        // å¹³æ»‘ç§»å‹•
        this.velocity.lerp(targetVelocity, 0.3);
        
        // æ‡‰ç”¨æ‘©æ“¦åŠ›
        if (targetVelocity.length() === 0) {
          this.velocity.multiplyScalar(this.friction);
        }
        
        // å¦‚æœé€Ÿåº¦å¾ˆå°å°±åœæ­¢
        if (this.velocity.length() < 0.001) {
          this.velocity.set(0, 0, 0);
        }
        
        // æ‡‰ç”¨ç§»å‹•åˆ°ç›¸æ©Ÿ
        if (this.velocity.length() > 0) {
          const moveVector = this.velocity.clone();
          // ä½¿ç”¨ç›¸æ©Ÿçš„å››å…ƒæ•¸ä¾†è®Šæ›ç§»å‹•æ–¹å‘
          moveVector.applyQuaternion(currentCamera.quaternion);
          
          // ç›´æ¥æ›´æ–°ç›¸æ©Ÿä½ç½®
          currentCamera.position.add(moveVector);
          
          // åŒæ­¥A-Frameå¯¦é«”ä½ç½®
          this.camEntity.object3D.position.copy(currentCamera.position);
          this.camEntity.setAttribute('position', {
            x: currentCamera.position.x,
            y: currentCamera.position.y,
            z: currentCamera.position.z
          });
        }
      }
      
      saveCameraState() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          currentCamera.updateMatrixWorld(true);
          this.savedState.position.copy(currentCamera.position);
          this.savedState.rotation.copy(currentCamera.rotation);
          this.savedState.quaternion.copy(currentCamera.quaternion);
          
          // ä¿å­˜é€è¦–ç›¸æ©Ÿçš„FOV
          if (currentCamera.isPerspectiveCamera) {
            this.savedPerspectiveFov = currentCamera.fov;
          }
        }
      }
      
      restoreCameraState(newCamera) {
        if (newCamera) {
          newCamera.position.copy(this.savedState.position);
          newCamera.rotation.copy(this.savedState.rotation);
          newCamera.quaternion.copy(this.savedState.quaternion);
          
          // ç¢ºä¿çŸ©é™£ç‹€æ…‹å®Œå…¨åŒæ­¥
          newCamera.updateMatrix();
          newCamera.updateMatrixWorld(true);
          newCamera.updateProjectionMatrix();
          
          // åŒæ­¥A-Frameå¯¦é«”çš„è®Šæ›ç‹€æ…‹
          const cameraEl = this.camEntity;
          cameraEl.object3D.position.copy(newCamera.position);
          cameraEl.object3D.rotation.copy(newCamera.rotation);
          cameraEl.object3D.quaternion.copy(newCamera.quaternion);
          cameraEl.object3D.updateMatrix();
          cameraEl.object3D.updateMatrixWorld(true);
          
          // åŒæ­¥åˆ°A-Frameçš„attributeç³»çµ±
          cameraEl.setAttribute('position', {
            x: newCamera.position.x,
            y: newCamera.position.y,
            z: newCamera.position.z
          });
          cameraEl.setAttribute('rotation', {
            x: THREE.MathUtils.radToDeg(newCamera.rotation.x),
            y: THREE.MathUtils.radToDeg(newCamera.rotation.y),
            z: THREE.MathUtils.radToDeg(newCamera.rotation.z)
          });
        }
      }
      
      // ç°¡åŒ–çš„å°„ç·šæª¢æ¸¬ï¼ˆå°ˆç‚ºå®¤å…§å ´æ™¯å„ªåŒ–ï¼‰
      getViewDirectionDistance(camera) {
        const raycaster = new THREE.Raycaster();
        const origin = new THREE.Vector3();
        const direction = new THREE.Vector3(0, 0, -1);
        
        // è¨­ç½®å°„ç·šèµ·é»å’Œæ–¹å‘
        camera.getWorldPosition(origin);
        direction.transformDirection(camera.matrixWorld);
        raycaster.set(origin, direction);
        
        // æ”¶é›†å ´æ™¯ä¸­çš„å¯¦é«”ç‰©é«”ï¼ˆæ’é™¤è¼”åŠ©å…ƒç´ ï¼‰
        const meshes = [];
        this.sceneEl.object3D.traverse((child) => {
          if (child.isMesh && child.visible && child.geometry) {
            // ç°¡å–®éæ¿¾ï¼šæ’é™¤ç›¸æ©Ÿå’Œç¶²æ ¼è¼”åŠ©ç·š
            const parentEl = child.parent?.el;
            if (parentEl?.id && ['grid', 'cameraRig', 'cam'].includes(parentEl.id)) {
              return;
            }
            meshes.push(child);
          }
        });
        
        // åŸ·è¡Œå°„ç·šæª¢æ¸¬
        const intersects = raycaster.intersectObjects(meshes, false);
        
        if (intersects.length > 0) {
          const distance = intersects[0].distance;
          // å®¤å…§ç©ºé–“ç¯„åœï¼šæœ€è¿‘0.3ç±³ï¼ˆç‰†å£ï¼‰ï¼Œæœ€é 30ç±³ï¼ˆé•·èµ°å»Š/å¤§å»³ï¼‰
          return Math.max(0.3, Math.min(30, distance));
        }
        
        // æ²’æœ‰å‘½ä¸­æ™‚çš„é»˜èªè·é›¢ï¼ˆä¸­ç­‰æˆ¿é–“å°ºå¯¸ï¼‰
        return 8.0;
      }
      
      // ä½¿ç”¨å°„ç·šæª¢æ¸¬çš„æ­£äº¤å°ºå¯¸è¨ˆç®—
      calculateOptimalOrthoSize() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return 5.0;
        
        // ç²å–ç•¶å‰FOV
        let currentFov = 60;
        if (!this.isOrtho && this.perspCam) {
          currentFov = this.perspCam.fov;
        } else if (this.savedPerspectiveFov) {
          currentFov = this.savedPerspectiveFov;
        }
        
        // æª¢æ¸¬è¦–ç·šæ–¹å‘çš„è·é›¢
        const distance = this.getViewDirectionDistance(currentCamera);
        
        // æ‡‰ç”¨æ•¸å­¸å…¬å¼ï¼šs = 2 * tan(fov/2) * d
        const fovRadians = THREE.MathUtils.degToRad(currentFov);
        const orthoSize = 2 * Math.tan(fovRadians / 2) * distance;
        
        return Math.max(0.2, Math.min(80, orthoSize));
      }
      
      // åå‘è¨ˆç®—FOVï¼ˆç•¶èª¿æ•´æ­£äº¤å°ºå¯¸æ™‚ï¼‰
      calculateCorrespondingFov(orthoSize) {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return 60;
        
        const distance = this.getViewDirectionDistance(currentCamera);
        
        // å¾æ­£äº¤å°ºå¯¸åæ¨FOV
        const tanHalfFov = orthoSize / (2 * distance);
        const fovRadians = 2 * Math.atan(tanHalfFov);
        const fovDegrees = THREE.MathUtils.radToDeg(fovRadians);
        
        return Math.max(10, Math.min(120, fovDegrees));
      }
      
      // åˆ‡æ›è¦–ç·šä¸­å¿ƒæŒ‡ç¤ºå™¨çš„é¡¯ç¤º/éš±è—
      toggleCrosshair() {
        this.crosshairVisible = !this.crosshairVisible;
        this.crosshair.style.display = this.crosshairVisible ? 'block' : 'none';
      }
      
      // æ ¹æ“šç›¸æ©Ÿæ¨¡å¼èª¿æ•´è¦–ç·šæŒ‡ç¤ºå™¨æ¨£å¼
      updateCrosshairStyle() {
        if (!this.crosshair) return;
        
        const circle = this.crosshair.querySelector('.crosshair-circle');
        if (!circle) return;
        
        if (this.isOrtho) {
          // æ­£äº¤æ¨¡å¼ï¼šæ›´å¯¦å¿ƒä¸€é»çš„æ¨£å¼
          circle.style.borderColor = 'rgba(0, 255, 136, 0.9)';
          circle.style.boxShadow = '0 0 12px rgba(0, 255, 136, 0.4), inset 0 0 12px rgba(0, 255, 136, 0.15)';
        } else {
          // é€è¦–æ¨¡å¼ï¼šåŸå§‹æ¨£å¼
          circle.style.borderColor = 'rgba(255, 255, 255, 0.8)';
          circle.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1)';
        }
      }
      
      toggleCamera() {
        this.saveCameraState();
        
        if (!this.isOrtho) {
          this.switchToOrthographic();
        } else {
          this.switchToPerspective();
        }
        
        this.updateCameraInfo();
        this.updateVisualEffects();
        this.updateCrosshairStyle();
      }
      
      switchToOrthographic() {
        const aspect = window.innerWidth / window.innerHeight;
        
        // åŸºäºå½“å‰é€è§†ç›¸æœºçš„FOVå’Œå½“å‰è§†çº¿è·ç¦»è®¡ç®—æ­£äº¤å°ºå¯¸
        const currentFov = this.perspCam ? this.perspCam.fov : this.savedPerspectiveFov || 60;
        const currentDistance = this.getViewDirectionDistance(this.perspCam || this.camEntity.getObject3D("camera"));
        
        // ä½¿ç”¨å½“å‰FOVå’Œè·ç¦»è®¡ç®—æ­£äº¤å°ºå¯¸ï¼Œä¿æŒè§†è§‰ä¸€è‡´æ€§
        const fovRadians = THREE.MathUtils.degToRad(currentFov);
        this.orthoSize = 2 * Math.tan(fovRadians / 2) * currentDistance;
        this.orthoSize = Math.max(0.2, Math.min(80, this.orthoSize));
        
        // ä¿å­˜å½“å‰çš„è§†çº¿è·ç¦»ï¼Œç”¨äºåç»­çš„FOVè®¡ç®—
        this.currentViewDistance = currentDistance;
        
        this.orthoCam = new THREE.OrthographicCamera(
          -this.orthoSize * aspect / 2, 
          this.orthoSize * aspect / 2,
          this.orthoSize / 2, 
          -this.orthoSize / 2,
          0.1, 
          1000
        );
        
        this.restoreCameraState(this.orthoCam);
        
        this.camEntity.setObject3D("camera", this.orthoCam);
        this.sceneEl.camera = this.orthoCam;
        
        // é‡ç½®é€Ÿåº¦é¿å…åˆ‡æ›å¾Œçš„ç§»å‹•å•é¡Œ
        this.velocity.set(0, 0, 0);
        this.orthoSizeVelocity = 0;
        
        this.label.textContent = "æ­£äº¤æ¨¡å¼";
        this.isOrtho = true;
        
        // ç¢ºä¿æ–°ç›¸æ©Ÿç«‹å³å¯ç”¨
        this.orthoCam.updateProjectionMatrix();
        this.orthoCam.updateMatrixWorld(true);
        
        if (this.debugMode) {
          console.log(`åˆ‡æ¢åˆ°æ­£äº¤æ¨¡å¼ - FOV: ${currentFov.toFixed(1)}Â°, è·ç¦»: ${currentDistance.toFixed(1)}, æ­£äº¤å°ºå¯¸: ${this.orthoSize.toFixed(1)}`);
        }
      }
      
      switchToPerspective() {
        const aspect = window.innerWidth / window.innerHeight;
        
        // åŸºäºå½“å‰æ­£äº¤å°ºå¯¸å’Œå½“å‰è§†çº¿è·ç¦»è®¡ç®—å¯¹åº”çš„FOV
        const currentDistance = this.getViewDirectionDistance(this.orthoCam || this.camEntity.getObject3D("camera"));
        
        // ä½¿ç”¨å½“å‰æ­£äº¤å°ºå¯¸å’Œè·ç¦»è®¡ç®—å¯¹åº”çš„FOVï¼Œä¿æŒè§†è§‰ä¸€è‡´æ€§
        const tanHalfFov = this.orthoSize / (2 * currentDistance);
        const fovRadians = 2 * Math.atan(tanHalfFov);
        const calculatedFov = THREE.MathUtils.radToDeg(fovRadians);
        const fov = Math.max(10, Math.min(120, calculatedFov));
        
        // æ›´æ–°ä¿å­˜çš„FOVå€¼
        this.savedPerspectiveFov = fov;
        
        this.perspCam = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
        
        this.restoreCameraState(this.perspCam);
        
        this.camEntity.setObject3D("camera", this.perspCam);
        this.sceneEl.camera = this.perspCam;
        
        // é‡ç½®é€Ÿåº¦é¿å…åˆ‡æ›å¾Œçš„ç§»å‹•å•é¡Œ
        this.velocity.set(0, 0, 0);
        
        this.label.textContent = "é€è¦–æ¨¡å¼";
        this.isOrtho = false;
        
        // ç¢ºä¿æ–°ç›¸æ©Ÿç«‹å³å¯ç”¨
        this.perspCam.updateProjectionMatrix();
        this.perspCam.updateMatrixWorld(true);
        
        if (this.debugMode) {
          console.log(`åˆ‡æ¢åˆ°é€è§†æ¨¡å¼ - æ­£äº¤å°ºå¯¸: ${this.orthoSize.toFixed(1)}, è·ç¦»: ${currentDistance.toFixed(1)}, FOV: ${fov.toFixed(1)}Â°`);
        }
      }
      
      resetCamera() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          // æš«æ™‚ç¦ç”¨look-controlsä»¥é¿å…è¡çª
          this.camEntity.setAttribute('look-controls', 'enabled', false);
          
          // é‡ç½®åˆ°åˆå§‹ä½ç½®å’Œæ—‹è½‰
          currentCamera.position.copy(this.defaultPosition);
          currentCamera.rotation.copy(this.defaultRotation);
          currentCamera.quaternion.setFromEuler(this.defaultRotation);
          currentCamera.updateMatrix();
          currentCamera.updateMatrixWorld(true);

          // é‡ç½® FOV å’Œæ­£äº¤å°ºå¯¸çš„å°æ‡‰é—œä¿‚
          if (!this.isOrtho) {
            currentCamera.fov = 60;
            this.savedPerspectiveFov = 60;
          } else {
            // é‡ç½®æ­£äº¤å°ºå¯¸
            this.orthoSize = this.defaultOrthoSize;
            const aspect = window.innerWidth / window.innerHeight;
            currentCamera.left = -this.orthoSize * aspect / 2;
            currentCamera.right = this.orthoSize * aspect / 2;
            currentCamera.top = this.orthoSize / 2;
            currentCamera.bottom = -this.orthoSize / 2;
            
            // åŒæ­¥é‡ç½®å°æ‡‰çš„é€è¦–FOV
            this.savedPerspectiveFov = 60;
          }
          currentCamera.updateProjectionMatrix();
          
          // åŒæ­¥A-Frameå¯¦é«”çš„ç‹€æ…‹
          this.camEntity.object3D.position.copy(currentCamera.position);
          this.camEntity.object3D.rotation.copy(currentCamera.rotation);
          this.camEntity.object3D.quaternion.copy(currentCamera.quaternion);
          this.camEntity.object3D.updateMatrix();
          this.camEntity.object3D.updateMatrixWorld(true);
          
          // åŒæ­¥åˆ°A-Frameçš„attributeç³»çµ±
          this.camEntity.setAttribute('position', {
            x: this.defaultPosition.x,
            y: this.defaultPosition.y,
            z: this.defaultPosition.z
          });
          this.camEntity.setAttribute('rotation', {
            x: THREE.MathUtils.radToDeg(this.defaultRotation.x),
            y: THREE.MathUtils.radToDeg(this.defaultRotation.y),
            z: THREE.MathUtils.radToDeg(this.defaultRotation.z)
          });
          
          // é‡ç½®look-controlsçš„å…§éƒ¨ç‹€æ…‹
          const lookControls = this.camEntity.components['look-controls'];
          if (lookControls) {
            lookControls.pitchObject.rotation.x = 0;
            lookControls.yawObject.rotation.y = 0;
            lookControls.yawObject.position.copy(this.defaultPosition);
          }
          
          // é‡ç½®é€Ÿåº¦
          this.velocity.set(0, 0, 0);
          
          // å»¶é²é‡æ–°å•Ÿç”¨look-controls
          setTimeout(() => {
            this.camEntity.setAttribute('look-controls', 'enabled', true);
          }, 50);
          
          this.updateCameraInfo();
          this.updatePositionInfo();
        }
      }
      
      updateOrthoSize() {
        if (!this.isOrtho || !this.orthoCam) return;
        
        // è¨ˆç®—ç›®æ¨™å°ºå¯¸è®ŠåŒ–
        let targetSizeChange = 0;
        if (this.keys.orthoShrink) targetSizeChange -= this.orthoSizeSpeed;
        if (this.keys.orthoGrow) targetSizeChange += this.orthoSizeSpeed;
        
        // å¹³æ»‘è®ŠåŒ–
        this.orthoSizeVelocity = THREE.MathUtils.lerp(this.orthoSizeVelocity, targetSizeChange, 0.3);
        
        // æ‡‰ç”¨æ‘©æ“¦åŠ›
        if (targetSizeChange === 0) {
          this.orthoSizeVelocity *= 0.9;
        }
        
        // å¦‚æœè®ŠåŒ–å¾ˆå°å°±åœæ­¢
        if (Math.abs(this.orthoSizeVelocity) < 0.001) {
          this.orthoSizeVelocity = 0;
        }
        
        // æ‡‰ç”¨å°ºå¯¸è®ŠåŒ–
        if (this.orthoSizeVelocity !== 0) {
          this.orthoSize += this.orthoSizeVelocity;
          this.orthoSize = Math.max(0.5, Math.min(50, this.orthoSize));
          
          const aspect = window.innerWidth / window.innerHeight;
          this.orthoCam.left = -this.orthoSize * aspect / 2;
          this.orthoCam.right = this.orthoSize * aspect / 2;
          this.orthoCam.top = this.orthoSize / 2;
          this.orthoCam.bottom = -this.orthoSize / 2;
          this.orthoCam.updateProjectionMatrix();
          
          // åŸºäºå½“å‰è·ç¦»è®¡ç®—å¯¹åº”çš„FOVï¼Œè€Œä¸æ˜¯å›ºå®šè·ç¦»
          const currentDistance = this.getViewDirectionDistance(this.orthoCam);
          const tanHalfFov = this.orthoSize / (2 * currentDistance);
          const fovRadians = 2 * Math.atan(tanHalfFov);
          const correspondingFov = THREE.MathUtils.radToDeg(fovRadians);
          this.savedPerspectiveFov = Math.max(10, Math.min(120, correspondingFov));
          
          this.updateCameraInfo();
        }
      }
      
      updateCameraInfo() {
        if (this.isOrtho) {
          const currentCamera = this.camEntity.getObject3D("camera");
          const detectedDistance = currentCamera ? this.getViewDirectionDistance(currentCamera) : 0;
          const correspondingFov = this.calculateCorrespondingFov(this.orthoSize);
          
          this.cameraInfo.textContent = `å°ºå¯¸: ${this.orthoSize.toFixed(1)} | æ­£äº¤æŠ•å½±`;
          
          // èª¿è©¦ä¿¡æ¯
          if (this.debugMode) {
            console.log(`æ­£äº¤æ¨¡å¼ - å°ºå¯¸: ${this.orthoSize.toFixed(1)}, æª¢æ¸¬è·é›¢: ${detectedDistance.toFixed(1)}, å°æ‡‰FOV: ${correspondingFov.toFixed(1)}Â°`);
          }
        } else if (this.perspCam) {
          const detectedDistance = this.getViewDirectionDistance(this.perspCam);
          const equivalentOrthoSize = this.calculateOptimalOrthoSize();
          
          this.cameraInfo.textContent = `FOV: ${this.perspCam.fov.toFixed(0)}Â° | é€è¦–æŠ•å½±`;
          
          // èª¿è©¦ä¿¡æ¯  
          if (this.debugMode) {
            console.log(`é€è¦–æ¨¡å¼ - FOV: ${this.perspCam.fov.toFixed(1)}Â°, æª¢æ¸¬è·é›¢: ${detectedDistance.toFixed(1)}, ç­‰æ•ˆæ­£äº¤å°ºå¯¸: ${equivalentOrthoSize.toFixed(1)}`);
          }
        }
      }
      
      updatePositionInfo() {
        // ç²å–ç›¸æ©Ÿå¯¦é«”å’Œå°è±¡
        const cameraEl = this.camEntity;
        const cameraObj = cameraEl.getObject3D('camera');
        
        if (cameraObj) {
          // ç²å–ä½ç½®ï¼ˆä¾†è‡ªç›¸æ©Ÿå°è±¡çš„ä¸–ç•Œä½ç½®ï¼‰
          const worldPos = new THREE.Vector3();
          cameraObj.getWorldPosition(worldPos);
          
          // ç²å–æ—‹è½‰ï¼ˆä¾†è‡ªç›¸æ©Ÿå°è±¡çš„ä¸–ç•Œå››å…ƒæ•¸ï¼‰
          const worldQuat = new THREE.Quaternion();
          cameraObj.getWorldQuaternion(worldQuat);
          
          // å°‡å››å…ƒæ•¸è½‰æ›ç‚ºæ­æ‹‰è§’
          const euler = new THREE.Euler();
          euler.setFromQuaternion(worldQuat, 'YXZ');
          
          // æ›´æ–°ä½ç½®é¡¯ç¤º
          this.positionInfo.textContent = 
            `ä½ç½®: (${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)}, ${worldPos.z.toFixed(1)})`;
          
          // æ›´æ–°æ—‹è½‰é¡¯ç¤ºï¼Œç¬¬ä¸‰å€‹å€¼å§‹çµ‚ç‚º0
          this.rotationInfo.textContent = 
            `æ—‹è½‰: (${(euler.x * 180 / Math.PI).toFixed(0)}Â°, ${(euler.y * 180 / Math.PI).toFixed(0)}Â°, 0Â°)`;
        }
      }
      
      updateVisualEffects() {
        const grid = document.getElementById("grid");
        if (grid) {
          grid.setAttribute("visible", this.isOrtho);
        }
      }
      
      startPerformanceMonitoring() {
        // FPSè®¡ç®—åœ¨animateå¾ªç¯ä¸­è¿›è¡Œï¼Œè¿™é‡Œä¸éœ€è¦setInterval
        this.lastTime = performance.now();
      }
      
      updatePerformanceInfo() {
        // æ¯å¸§æ›´æ–°FPSè®¡ç®—
        const currentTime = performance.now();
        const deltaTime = currentTime - this.lastTime;
        
        // å°†å¸§æ—¶é—´æ·»åŠ åˆ°ç¼“å†²åŒº
        this.frameTimeBuffer.push(deltaTime);
        if (this.frameTimeBuffer.length > this.bufferSize) {
          this.frameTimeBuffer.shift();
        }
        
        // æ¯30å¸§æ›´æ–°ä¸€æ¬¡æ˜¾ç¤ºï¼ˆçº¦0.5ç§’ï¼‰
        if (this.frameCount % 30 === 0 && this.frameTimeBuffer.length > 10) {
          // è®¡ç®—å¹³å‡å¸§æ—¶é—´
          const avgFrameTime = this.frameTimeBuffer.reduce((sum, time) => sum + time, 0) / this.frameTimeBuffer.length;
          this.fps = Math.round(1000 / avgFrameTime);
          
          const objectCount = this.sceneEl.querySelectorAll('a-entity, a-sphere, a-box, a-cylinder, a-torus, a-plane').length;
          this.performanceInfo.textContent = `FPS: ${this.fps} | ç‰©ä»¶: ${objectCount}`;
        }
        
        this.lastTime = currentTime;
      }
      
      handleResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const threeCam = this.camEntity.getObject3D("camera");
        
        if (!threeCam) return;
        
        if (threeCam.isPerspectiveCamera) {
          threeCam.aspect = aspect;
          threeCam.updateProjectionMatrix();
        } else if (threeCam.isOrthographicCamera) {
          threeCam.left = -this.orthoSize * aspect / 2;
          threeCam.right = this.orthoSize * aspect / 2;
          threeCam.top = this.orthoSize / 2;
          threeCam.bottom = -this.orthoSize / 2;
          threeCam.updateProjectionMatrix();
        }
      }
    }
    
    // åˆå§‹åŒ–æ§åˆ¶å™¨
    document.addEventListener('DOMContentLoaded', () => {
      new EnhancedCameraController();
    });
  </script>
</body>
</html>