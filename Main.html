<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced Camera Toggle VR Scene</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { 
      margin: 0; 
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
    }
    
    .camera-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 12px;
      color: white;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .control-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .control-row:last-child {
      margin-bottom: 0;
    }
    
    .toggle-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .toggle-btn:active {
      transform: translateY(0);
    }
    
    .mode-label {
      font-weight: bold;
      font-size: 16px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }
    
    .camera-info {
      font-size: 12px;
      color: #b0b0b0;
      margin-top: 8px;
      font-family: 'Courier New', monospace;
    }
    
    .position-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .rotation-info {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .instructions {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.85);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      max-width: 280px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .instructions h4 {
      margin: 0 0 10px 0;
      color: #00ff88;
      font-size: 14px;
    }
    
    .control-group {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }
    
    .performance-info {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 6px;
      color: #00ff88;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      border: 1px solid rgba(0, 255, 136, 0.2);
    }
  </style>
</head>
<body>
  <div class="camera-controls">
    <div class="control-row">
      <button id="toggleBtn" class="toggle-btn">切換相機</button>
      <span id="modeLabel" class="mode-label">透視模式</span>
    </div>
    <div id="cameraInfo" class="camera-info">FOV: 60° | 透視投影</div>
    <div id="positionInfo" class="position-info">位置: (0.0, 1.6, 3.0)</div>
    <div id="rotationInfo" class="rotation-info">旋轉: (0°, 0°, 0°)</div>
  </div>
  
  <div class="performance-info" id="performanceInfo">
    FPS: -- | 物件: --
  </div>
  
  <div class="instructions">
    <h4>🎮 控制說明</h4>
    <div class="control-group">
      <span class="key">滑鼠拖曳</span> 旋轉視角<br>
      <span class="key">WASD</span> / <span class="key">方向鍵</span> 移動相機
    </div>
    <div class="control-group">
      <span class="key">空白鍵</span> 切換相機模式<br>
      <span class="key">滾輪</span> 縮放 (透視模式)
    </div>
    <div class="control-group">
      <span class="key">WS</span> 調整正交尺寸 (正交模式)<br>
      <span class="key">R</span> 重置相機位置
    </div>
  </div>

  <a-scene id="mainScene" background="color: #0f0f23" fog="type: exponential; color: #0f0f23; density: 0.02">
    <a-entity id="cameraRig" position="0 1.6 3">
      <a-camera id="cam" look-controls wasd-controls="enabled: false"></a-camera>
    </a-entity>
    
    <!-- 創建一個更豐富的3D場景 -->
    
    <!-- 中央旋轉球體 -->
    <a-sphere position="0 2 0" radius="0.8" color="#ff6b6b" 
              material="metalness: 0.7; roughness: 0.3"
              animation="property: rotation; to: 0 360 0; loop: true; dur: 4000"
              animation__bounce="property: position; to: 0 3 0; dir: alternate; loop: true; dur: 3000; easing: easeInOutSine"></a-sphere>
    
    <!-- 左側跳躍方塊 -->
    <a-box position="-4 1 0" rotation="0 45 0" color="#4ecdc4" 
           material="metalness: 0.5; roughness: 0.4"
           animation="property: position; to: -4 3 0; dir: alternate; loop: true; dur: 2000; easing: easeInOutBounce"
           animation__rotate="property: rotation; to: 360 45 360; loop: true; dur: 5000"></a-box>
    

    <!-- 後方旋轉環 -->
    <a-torus position="0 2 -5" color="#96ceb4" radius="1.5" radius-tubular="0.2"
             material="metalness: 0.8; roughness: 0.1"
             animation="property: rotation; to: 360 360 0; loop: true; dur: 6000"></a-torus>
    
    <!-- 地板和牆壁 -->
    <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" 
             color="#2c3e50" material="metalness: 0.1; roughness: 0.9"></a-plane>
    
    <!-- 背景牆 -->
    <a-plane position="0 5 -10" rotation="0 0 0" width="20" height="10" 
             color="#34495e" material="opacity: 0.7; transparent: true"></a-plane>
    
    <!-- 網格幫助線 -->
    <a-entity id="grid" visible="false">
      <a-plane position="0 0.01 0" rotation="-90 0 0" width="20" height="20" 
               material="color: #555; opacity: 0.3; transparent: true" wireframe="true"></a-plane>
      <!-- 座標軸指示器 -->
      <a-box position="1 0.05 0" width="2" height="0.1" depth="0.1" color="#ff0000"></a-box>
      <a-box position="0 1 0" width="0.1" height="2" depth="0.1" color="#00ff00"></a-box>
      <a-box position="0 0.05 1" width="0.1" height="0.1" depth="2" color="#0000ff"></a-box>
    </a-entity>
    
    <!-- 增強光源系統 -->
    <a-light type="ambient" color="#404040" intensity="0.3"></a-light>
    <a-light type="point" position="3 5 3" color="#ffffff" intensity="0.8" 
             animation="property: position; to: -3 5 -3; dir: alternate; loop: true; dur: 10000"></a-light>
    <a-light type="point" position="-3 5 3" color="#ff6b6b" intensity="0.6"
             animation="property: position; to: 3 5 -3; dir: alternate; loop: true; dur: 8000"></a-light>
    <a-light type="directional" position="0 10 0" color="#87ceeb" intensity="0.4"></a-light>
  </a-scene>

  <script>
    class EnhancedCameraController {
      constructor() {
        this.sceneEl = document.querySelector("a-scene");
        this.camEntity = document.getElementById("cam");
        this.cameraRig = document.getElementById("cameraRig");
        this.label = document.getElementById("modeLabel");
        this.toggleBtn = document.getElementById("toggleBtn");
        this.cameraInfo = document.getElementById("cameraInfo");
        this.positionInfo = document.getElementById("positionInfo");
        this.rotationInfo = document.getElementById("rotationInfo");
        this.performanceInfo = document.getElementById("performanceInfo");
        
        this.isOrtho = false;
        this.orthoCam = null;
        this.perspCam = null;
        this.orthoSize = 5;
        
        // 相機狀態保存
        this.savedState = {
          position: new THREE.Vector3(0, 1.6, 3),
          rotation: new THREE.Euler(),
          quaternion: new THREE.Quaternion()
        };
        
        // 移動控制
        this.keys = {};
        this.moveSpeed = 0.1; // 統一的移動速度
        this.smoothing = 0.1;
        this.velocity = new THREE.Vector3();
        this.acceleration = 0.02;
        this.friction = 0.9;
        
        // 滑鼠狀態
        this.isMouseDown = false;
        this.isTouchDown = false;
        
        // 性能監控
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
        
        // 默認相機位置
        this.defaultPosition = new THREE.Vector3(0, 1.6, 3);
        this.defaultRotation = new THREE.Euler(0, 0, 0);
        
        this.init();
      }
      
      init() {
        this.sceneEl.addEventListener("loaded", () => {
          // 立即替換默認相機，確保從一開始就使用統一的相機系統
          const aspect = window.innerWidth / window.innerHeight;
          this.perspCam = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
          
          // 設置初始位置和旋轉
          this.perspCam.position.copy(this.defaultPosition);
          this.perspCam.rotation.copy(this.defaultRotation);
          this.perspCam.quaternion.setFromEuler(this.defaultRotation);
          this.perspCam.updateMatrix();
          this.perspCam.updateMatrixWorld(true);
          this.perspCam.updateProjectionMatrix();
          
          // 同步A-Frame實體狀態
          this.camEntity.object3D.position.copy(this.perspCam.position);
          this.camEntity.object3D.rotation.copy(this.perspCam.rotation);
          this.camEntity.object3D.quaternion.copy(this.perspCam.quaternion);
          this.camEntity.object3D.updateMatrix();
          this.camEntity.object3D.updateMatrixWorld(true);
          
          // 替換默認相機
          this.camEntity.setObject3D("camera", this.perspCam);
          this.sceneEl.camera = this.perspCam;
          
          this.updateCameraInfo();
          this.setupEventListeners();
          this.startPerformanceMonitoring();
          this.animate();
        });
      }
      
      setupEventListeners() {
        // 按鈕切換
        this.toggleBtn.addEventListener("click", () => this.toggleCamera());
        
        // 鍵盤控制
        document.addEventListener("keydown", (e) => this.handleKeyDown(e));
        document.addEventListener("keyup", (e) => this.handleKeyUp(e));
        
        // 滾輪縮放
        this.sceneEl.addEventListener("wheel", (e) => this.handleWheel(e), { passive: false });
        
        // 視窗大小變化
        window.addEventListener("resize", () => this.handleResize());
        
        // 使用 setInterval 定期更新旋轉信息
        setInterval(() => {
          this.updatePositionInfo();
        }, 50); // 每50毫秒更新一次（20 FPS）
      }
      
      handleKeyDown(e) {
        if (e.repeat) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            this.toggleCamera();
            break;
          case 'KeyR':
            e.preventDefault();
            this.resetCamera();
            break;
          case 'KeyW':
            if (this.isOrtho) {
              e.preventDefault();
              this.adjustOrthoSize(0.9);
            } else {
              this.keys.forward = true;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              e.preventDefault();
              this.adjustOrthoSize(1.1);
            } else {
              this.keys.backward = true;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = true;
            break;
          case 'ArrowDown':
            this.keys.backward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = true;
            break;
        }
      }
      
      handleKeyUp(e) {
        switch(e.code) {
          case 'KeyW':
            if (!this.isOrtho) {
              this.keys.forward = false;
            }
            break;
          case 'KeyS':
            if (!this.isOrtho) {
              this.keys.backward = false;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = false;
            break;
          case 'ArrowDown':
            this.keys.backward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = false;
            break;
        }
      }
      
      handleWheel(e) {
        if (!this.isOrtho && this.perspCam) {
          e.preventDefault();
          const currentFov = this.perspCam.fov;
          const delta = e.deltaY * 0.1;
          const newFov = Math.max(10, Math.min(120, currentFov + delta));
          
          this.perspCam.fov = newFov;
          this.perspCam.updateProjectionMatrix();
          this.updateCameraInfo();
        }
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        
        // 更新移動
        this.updateMovement();
        
        // 更新性能信息
        this.updatePerformanceInfo();
        
        this.frameCount++;
      }
      
      updateMovement() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (!currentCamera) return;
        
        // 計算目標移動方向
        const targetVelocity = new THREE.Vector3();
        
        if (this.keys.forward) targetVelocity.z -= 1;
        if (this.keys.backward) targetVelocity.z += 1;
        if (this.keys.left) targetVelocity.x -= 1;
        if (this.keys.right) targetVelocity.x += 1;
        
        // 正規化移動向量並應用統一速度
        if (targetVelocity.length() > 0) {
          targetVelocity.normalize();
          targetVelocity.multiplyScalar(this.moveSpeed);
        }
        
        // 平滑移動
        this.velocity.lerp(targetVelocity, 0.3);
        
        // 應用摩擦力
        if (targetVelocity.length() === 0) {
          this.velocity.multiplyScalar(this.friction);
        }
        
        // 如果速度很小就停止
        if (this.velocity.length() < 0.001) {
          this.velocity.set(0, 0, 0);
        }
        
        // 應用移動到相機
        if (this.velocity.length() > 0) {
          const moveVector = this.velocity.clone();
          // 使用相機的四元數來變換移動方向
          moveVector.applyQuaternion(currentCamera.quaternion);
          
          // 直接更新相機位置
          currentCamera.position.add(moveVector);
          
          // 同步A-Frame實體位置
          this.camEntity.object3D.position.copy(currentCamera.position);
          this.camEntity.setAttribute('position', {
            x: currentCamera.position.x,
            y: currentCamera.position.y,
            z: currentCamera.position.z
          });
        }
      }
      
      saveCameraState() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          currentCamera.updateMatrixWorld(true);
          this.savedState.position.copy(currentCamera.position);
          this.savedState.rotation.copy(currentCamera.rotation);
          this.savedState.quaternion.copy(currentCamera.quaternion);
        }
      }
      
      restoreCameraState(newCamera) {
        if (newCamera) {
          newCamera.position.copy(this.savedState.position);
          newCamera.rotation.copy(this.savedState.rotation);
          newCamera.quaternion.copy(this.savedState.quaternion);
          
          // 確保矩陣狀態完全同步
          newCamera.updateMatrix();
          newCamera.updateMatrixWorld(true);
          newCamera.updateProjectionMatrix();
          
          // 同步A-Frame實體的變換狀態
          const cameraEl = this.camEntity;
          cameraEl.object3D.position.copy(newCamera.position);
          cameraEl.object3D.rotation.copy(newCamera.rotation);
          cameraEl.object3D.quaternion.copy(newCamera.quaternion);
          cameraEl.object3D.updateMatrix();
          cameraEl.object3D.updateMatrixWorld(true);
          
          // 同步到A-Frame的attribute系統
          cameraEl.setAttribute('position', {
            x: newCamera.position.x,
            y: newCamera.position.y,
            z: newCamera.position.z
          });
          cameraEl.setAttribute('rotation', {
            x: THREE.MathUtils.radToDeg(newCamera.rotation.x),
            y: THREE.MathUtils.radToDeg(newCamera.rotation.y),
            z: THREE.MathUtils.radToDeg(newCamera.rotation.z)
          });
        }
      }
      
      toggleCamera() {
        this.saveCameraState();
        
        if (!this.isOrtho) {
          this.switchToOrthographic();
        } else {
          this.switchToPerspective();
        }
        
        this.updateCameraInfo();
        this.updateVisualEffects();
      }
      
      switchToOrthographic() {
        const aspect = window.innerWidth / window.innerHeight;
        
        this.orthoCam = new THREE.OrthographicCamera(
          -this.orthoSize * aspect / 2, 
          this.orthoSize * aspect / 2,
          this.orthoSize / 2, 
          -this.orthoSize / 2,
          0.1, 
          1000
        );
        
        this.restoreCameraState(this.orthoCam);
        
        this.camEntity.setObject3D("camera", this.orthoCam);
        this.sceneEl.camera = this.orthoCam;
        
        // 重置速度避免切換後的移動問題
        this.velocity.set(0, 0, 0);
        
        this.label.textContent = "正交模式";
        this.isOrtho = true;
        
        // 確保新相機立即可用
        this.orthoCam.updateProjectionMatrix();
        this.orthoCam.updateMatrixWorld(true);
      }
      
      switchToPerspective() {
        const aspect = window.innerWidth / window.innerHeight;
        const fov = this.perspCam ? this.perspCam.fov : 60;
        
        this.perspCam = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
        
        this.restoreCameraState(this.perspCam);
        
        this.camEntity.setObject3D("camera", this.perspCam);
        this.sceneEl.camera = this.perspCam;
        
        // 重置速度避免切換後的移動問題
        this.velocity.set(0, 0, 0);
        
        this.label.textContent = "透視模式";
        this.isOrtho = false;
        
        // 確保新相機立即可用
        this.perspCam.updateProjectionMatrix();
        this.perspCam.updateMatrixWorld(true);
      }
      
      resetCamera() {
        const currentCamera = this.camEntity.getObject3D("camera");
        if (currentCamera) {
          currentCamera.position.copy(this.defaultPosition);
          currentCamera.rotation.copy(this.defaultRotation);
          currentCamera.quaternion.setFromEuler(this.defaultRotation);
          currentCamera.updateMatrix();
          currentCamera.updateMatrixWorld(true);
          this.updatePositionInfo();
        }
      }
      
      adjustOrthoSize(factor) {
        if (!this.isOrtho || !this.orthoCam) return;
        
        this.orthoSize *= factor;
        this.orthoSize = Math.max(0.5, Math.min(50, this.orthoSize));
        
        const aspect = window.innerWidth / window.innerHeight;
        this.orthoCam.left = -this.orthoSize * aspect / 2;
        this.orthoCam.right = this.orthoSize * aspect / 2;
        this.orthoCam.top = this.orthoSize / 2;
        this.orthoCam.bottom = -this.orthoSize / 2;
        this.orthoCam.updateProjectionMatrix();
        
        this.updateCameraInfo();
      }
      
      updateCameraInfo() {
        if (this.isOrtho) {
          this.cameraInfo.textContent = `尺寸: ${this.orthoSize.toFixed(1)} | 正交投影`;
        } else if (this.perspCam) {
          this.cameraInfo.textContent = `FOV: ${this.perspCam.fov.toFixed(0)}° | 透視投影`;
        }
      }
      
      updatePositionInfo() {
        // 獲取相機實體和對象
        const cameraEl = this.camEntity;
        const cameraObj = cameraEl.getObject3D('camera');
        
        if (cameraObj) {
          // 獲取位置（來自相機對象的世界位置）
          const worldPos = new THREE.Vector3();
          cameraObj.getWorldPosition(worldPos);
          
          // 獲取旋轉（來自相機對象的世界四元數）
          const worldQuat = new THREE.Quaternion();
          cameraObj.getWorldQuaternion(worldQuat);
          
          // 將四元數轉換為歐拉角
          const euler = new THREE.Euler();
          euler.setFromQuaternion(worldQuat, 'YXZ');
          
          // 更新位置顯示
          this.positionInfo.textContent = 
            `位置: (${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)}, ${worldPos.z.toFixed(1)})`;
          
          // 更新旋轉顯示，第三個值始終為0
          this.rotationInfo.textContent = 
            `旋轉: (${(euler.x * 180 / Math.PI).toFixed(0)}°, ${(euler.y * 180 / Math.PI).toFixed(0)}°, 0°)`;
        }
      }
      
      updateVisualEffects() {
        const grid = document.getElementById("grid");
        grid.setAttribute("visible", this.isOrtho);
      }
      
      startPerformanceMonitoring() {
        setInterval(() => {
          const now = performance.now();
          this.fps = Math.round(1000 / (now - this.lastTime));
          this.lastTime = now;
        }, 1000);
      }
      
      updatePerformanceInfo() {
        if (this.frameCount % 30 === 0) {
          const objectCount = this.sceneEl.querySelectorAll('a-entity, a-sphere, a-box, a-cylinder, a-torus, a-plane').length;
          this.performanceInfo.textContent = `FPS: ${this.fps} | 物件: ${objectCount}`;
        }
      }
      
      handleResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const threeCam = this.camEntity.getObject3D("camera");
        
        if (!threeCam) return;
        
        if (threeCam.isPerspectiveCamera) {
          threeCam.aspect = aspect;
          threeCam.updateProjectionMatrix();
        } else if (threeCam.isOrthographicCamera) {
          threeCam.left = -this.orthoSize * aspect / 2;
          threeCam.right = this.orthoSize * aspect / 2;
          threeCam.top = this.orthoSize / 2;
          threeCam.bottom = -this.orthoSize / 2;
          threeCam.updateProjectionMatrix();
        }
      }
    }
    
    // 初始化控制器
    document.addEventListener('DOMContentLoaded', () => {
      new EnhancedCameraController();
    });
  </script>
</body>
</html>