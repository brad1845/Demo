<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced Camera Toggle with Babylon.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/6.33.1/babylon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/6.33.1/babylonjs.loaders.min.js"></script>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
      background: #0f0f23;
    }
    
    #babylon-canvas {
      width: 100%;
      height: 100vh;
      display: block;
      outline: none;
    }
    
    .camera-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 12px;
      color: white;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      min-width: 280px;
    }
    
    .control-row {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .control-row:last-child {
      margin-bottom: 0;
    }
    
    .toggle-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }
    
    .toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
    }
    
    .toggle-btn:active {
      transform: translateY(0);
    }
    
    .mode-label {
      font-weight: bold;
      font-size: 18px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.4);
    }
    
    .camera-info {
      font-size: 13px;
      color: #b0b0b0;
      margin-top: 10px;
      font-family: 'Courier New', monospace;
      line-height: 1.4;
    }
    
    .position-info {
      font-size: 12px;
      color: #888;
      margin-top: 6px;
      font-family: 'Courier New', monospace;
    }
    
    .rotation-info {
      font-size: 12px;
      color: #888;
      margin-top: 4px;
      font-family: 'Courier New', monospace;
    }
    
    .instructions {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.88);
      padding: 18px;
      border-radius: 10px;
      color: white;
      font-size: 13px;
      max-width: 320px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }
    
    .instructions h4 {
      margin: 0 0 12px 0;
      color: #00ff88;
      font-size: 16px;
      text-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
    }
    
    .control-group {
      margin-bottom: 10px;
      line-height: 1.5;
    }
    
    .key {
      background: rgba(255, 255, 255, 0.12);
      padding: 3px 8px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 11px;
    }
    
    .performance-info {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.85);
      padding: 12px 16px;
      border-radius: 8px;
      color: #00ff88;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      border: 1px solid rgba(0, 255, 136, 0.3);
      backdrop-filter: blur(8px);
      text-shadow: 0 0 6px rgba(0, 255, 136, 0.2);
    }
    
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      pointer-events: none;
      width: 28px;
      height: 28px;
    }
    
    .crosshair-circle {
      width: 100%;
      height: 100%;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      background: transparent;
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.3), inset 0 0 12px rgba(255, 255, 255, 0.1);
      animation: crosshair-pulse 2.5s ease-in-out infinite alternate;
    }
    
    @keyframes crosshair-pulse {
      0% {
        border-color: rgba(255, 255, 255, 0.6);
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.2), inset 0 0 8px rgba(255, 255, 255, 0.05);
        transform: scale(0.95);
      }
      100% {
        border-color: rgba(255, 255, 255, 1);
        box-shadow: 0 0 16px rgba(255, 255, 255, 0.5), inset 0 0 16px rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }
    }
    
    .debug-info {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 999;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 6px;
      color: #ffaa00;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      border: 1px solid rgba(255, 170, 0, 0.2);
      display: none;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <canvas id="babylon-canvas"></canvas>
  
  <div class="camera-controls">
    <div class="control-row">
      <button id="toggleBtn" class="toggle-btn">åˆ‡æ›ç›¸æ©Ÿ</button>
      <span id="modeLabel" class="mode-label">é€è¦–æ¨¡å¼</span>
    </div>
    <div id="cameraInfo" class="camera-info">FOV: 60Â° | é€è¦–æŠ•å½±<br>è·é›¢æª¢æ¸¬: æº–å‚™ä¸­...</div>
    <div id="positionInfo" class="position-info">ä½ç½®: (0.0, 1.6, 3.0)</div>
    <div id="rotationInfo" class="rotation-info">æ—‹è½‰: (0Â°, 0Â°, 0Â°)</div>
  </div>
  
  <div class="performance-info" id="performanceInfo">
    FPS: -- | ç‰©ä»¶: -- | å¼•æ“: Babylon.js
  </div>
  
  <!-- è¦–ç·šä¸­å¿ƒæŒ‡ç¤ºå™¨ -->
  <div class="crosshair" id="crosshair">
    <div class="crosshair-circle"></div>
  </div>
  
  <!-- èª¿è©¦ä¿¡æ¯ -->
  <div class="debug-info" id="debugInfo">
    èª¿è©¦æ¨¡å¼å·²é–‹å•Ÿ<br>
    <span id="debugContent"></span>
  </div>
  
  <div class="instructions">
    <h4>ğŸ® æ§åˆ¶èªªæ˜</h4>
    <div class="control-group">
      <span class="key">æ»‘é¼ å·¦éµæ‹–æ›³</span> æ—‹è½‰è¦–è§’<br>
      <span class="key">æ»‘é¼ å³éµæ‹–æ›³</span> å¹³ç§»ç›¸æ©Ÿ
    </div>
    <div class="control-group">
      <span class="key">WASD</span> / <span class="key">æ–¹å‘éµ</span> ç§»å‹•ç›¸æ©Ÿ<br>
      <span class="key">æ»¾è¼ª</span> ç¸®æ”¾è¦–è§’
    </div>
    <div class="control-group">
      <span class="key">ç©ºç™½éµ</span> åˆ‡æ›ç›¸æ©Ÿæ¨¡å¼<br>
      <span class="key">WS</span> èª¿æ•´æ­£äº¤å°ºå¯¸ (æ­£äº¤æ¨¡å¼)
    </div>
    <div class="control-group">
      <span class="key">R</span> é‡ç½®ç›¸æ©Ÿä½ç½®<br>
      <span class="key">C</span> åˆ‡æ›è¦–ç·šæŒ‡ç¤ºå™¨<br>
      <span class="key">G</span> èª¿è©¦æ¨¡å¼é–‹é—œ
    </div>
  </div>

  <script>
    class BabylonCameraController {
      constructor() {
        this.canvas = document.getElementById("babylon-canvas");
        this.engine = null;
        this.scene = null;
        this.perspectiveCamera = null;
        this.orthographicCamera = null;
        this.currentCamera = null;
        this.isOrtho = false;
        
        // UI å…ƒç´ 
        this.label = document.getElementById("modeLabel");
        this.toggleBtn = document.getElementById("toggleBtn");
        this.cameraInfo = document.getElementById("cameraInfo");
        this.positionInfo = document.getElementById("positionInfo");
        this.rotationInfo = document.getElementById("rotationInfo");
        this.performanceInfo = document.getElementById("performanceInfo");
        this.crosshair = document.getElementById("crosshair");
        this.debugInfo = document.getElementById("debugInfo");
        this.debugContent = document.getElementById("debugContent");
        
        // ç›¸æ©Ÿåƒæ•¸
        this.defaultFov = Math.PI / 3; // 60 degrees in radians
        this.savedPerspectiveFov = this.defaultFov;
        this.orthoSize = 5;
        this.defaultPosition = new BABYLON.Vector3(0, 1.6, 3);
        this.defaultTarget = new BABYLON.Vector3(0, 1.6, 0);
        
        // ç§»å‹•æ§åˆ¶
        this.keys = {};
        this.moveSpeed = 0.1;
        this.velocity = new BABYLON.Vector3(0, 0, 0);
        
        // æ­£äº¤å°ºå¯¸æ§åˆ¶
        this.orthoSizeVelocity = 0;
        this.orthoSizeSpeed = 0.15;
        
        // æ€§èƒ½ç›£æ§
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
        this.frameTimeBuffer = [];
        this.bufferSize = 60;
        
        // è¦–ç·šæŒ‡ç¤ºå™¨
        this.crosshairVisible = true;
        
        // èª¿è©¦æ¨¡å¼
        this.debugMode = false;
        
        // å ´æ™¯ç‰©é«”ï¼ˆç”¨æ–¼å°„ç·šæª¢æ¸¬ï¼‰
        this.sceneObjects = [];
        
        this.init();
      }
      
      async init() {
        // å‰µå»ºå¼•æ“å’Œå ´æ™¯
        this.engine = new BABYLON.Engine(this.canvas, true, {
          adaptToDeviceRatio: true,
          antialias: true,
          stencil: true
        });
        
        this.scene = new BABYLON.Scene(this.engine);
        this.scene.clearColor = new BABYLON.Color3(0.06, 0.06, 0.14);
        
        // å‰µå»ºç›¸æ©Ÿ
        this.createCameras();
        
        // å‰µå»ºå ´æ™¯å…§å®¹
        this.createScene();
        
        // è¨­ç½®å…‰ç…§
        this.setupLighting();
        
        // è¨­ç½®äº‹ä»¶ç›£è½
        this.setupEventListeners();
        
        // é–‹å§‹æ¸²æŸ“å¾ªç’°
        this.startRenderLoop();
        
        // åˆå§‹åŒ–UI
        this.updateCameraInfo();
        
        console.log("Babylon.js ç›¸æ©Ÿç³»çµ±åˆå§‹åŒ–å®Œæˆ");
      }
      
      createCameras() {
        // å‰µå»ºé€è¦–ç›¸æ©Ÿ
        this.perspectiveCamera = new BABYLON.UniversalCamera("perspectiveCamera", 
          this.defaultPosition.clone(), this.scene);
        this.perspectiveCamera.setTarget(this.defaultTarget);
        this.perspectiveCamera.fov = this.defaultFov;
        this.perspectiveCamera.minZ = 0.1;
        this.perspectiveCamera.maxZ = 1000;
        
        // è¨­ç½®ç›¸æ©Ÿæ§åˆ¶
        this.perspectiveCamera.attachControls(this.canvas);
        this.perspectiveCamera.inputs.addMouseWheel();
        
        // å‰µå»ºæ­£äº¤ç›¸æ©Ÿ
        const aspect = this.canvas.width / this.canvas.height;
        this.orthographicCamera = new BABYLON.UniversalCamera("orthographicCamera", 
          this.defaultPosition.clone(), this.scene);
        this.orthographicCamera.setTarget(this.defaultTarget);
        this.orthographicCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
        this.orthographicCamera.orthoLeft = -this.orthoSize * aspect / 2;
        this.orthographicCamera.orthoRight = this.orthoSize * aspect / 2;
        this.orthographicCamera.orthoTop = this.orthoSize / 2;
        this.orthographicCamera.orthoBottom = -this.orthoSize / 2;
        this.orthographicCamera.minZ = 0.1;
        this.orthographicCamera.maxZ = 1000;
        
        // è¨­ç½®ç•¶å‰ç›¸æ©Ÿ
        this.currentCamera = this.perspectiveCamera;
        this.scene.activeCamera = this.currentCamera;
      }
      
      createScene() {
        // å‰µå»ºåœ°é¢
        const ground = BABYLON.MeshBuilder.CreateGround("ground", {
          width: 20, height: 20
        }, this.scene);
        const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", this.scene);
        groundMaterial.diffuseColor = new BABYLON.Color3(0.17, 0.24, 0.31);
        groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        ground.material = groundMaterial;
        ground.receiveShadows = true;
        this.sceneObjects.push(ground);
        
        // å‰µå»ºæ¸¬è©¦ç‰©é«” - å³å´ç´…è‰²æ–¹å¡Š
        const redBox = BABYLON.MeshBuilder.CreateBox("redBox", {size: 1}, this.scene);
        redBox.position = new BABYLON.Vector3(4, 1.6, 0);
        const redMaterial = new BABYLON.StandardMaterial("redMaterial", this.scene);
        redMaterial.diffuseColor = new BABYLON.Color3(0.91, 0.30, 0.24);
        redMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
        redBox.material = redMaterial;
        this.sceneObjects.push(redBox);
        
        // å‰µå»ºæ¸¬è©¦ç‰©é«” - å‰æ–¹æ©™è‰²çƒé«”
        const orangeSphere = BABYLON.MeshBuilder.CreateSphere("orangeSphere", {diameter: 1}, this.scene);
        orangeSphere.position = new BABYLON.Vector3(0, 1.6, -3);
        const orangeMaterial = new BABYLON.StandardMaterial("orangeMaterial", this.scene);
        orangeMaterial.diffuseColor = new BABYLON.Color3(0.95, 0.61, 0.07);
        orangeMaterial.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
        orangeSphere.material = orangeMaterial;
        this.sceneObjects.push(orangeSphere);
        
        // å‰µå»ºæ¸¬è©¦ç‰©é«” - å·¦å‰æ–¹ç´«è‰²åœ“ç’°
        const purpleTorus = BABYLON.MeshBuilder.CreateTorus("purpleTorus", {
          diameter: 1.2, thickness: 0.3
        }, this.scene);
        purpleTorus.position = new BABYLON.Vector3(-2, 1.6, -4);
        const purpleMaterial = new BABYLON.StandardMaterial("purpleMaterial", this.scene);
        purpleMaterial.diffuseColor = new BABYLON.Color3(0.61, 0.35, 0.71);
        purpleMaterial.specularColor = new BABYLON.Color3(0.6, 0.3, 0.6);
        purpleTorus.material = purpleMaterial;
        this.sceneObjects.push(purpleTorus);
        
        // å‰µå»ºèƒŒæ™¯ç‰†
        const backWall = BABYLON.MeshBuilder.CreatePlane("backWall", {
          width: 20, height: 10
        }, this.scene);
        backWall.position = new BABYLON.Vector3(0, 5, -10);
        const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", this.scene);
        wallMaterial.diffuseColor = new BABYLON.Color3(0.20, 0.29, 0.37);
        wallMaterial.alpha = 0.7;
        backWall.material = wallMaterial;
        this.sceneObjects.push(backWall);
        
        // æ·»åŠ ä¸€äº›è£é£¾æ€§å¹¾ä½•é«”
        for (let i = 0; i < 3; i++) {
          const cylinder = BABYLON.MeshBuilder.CreateCylinder(`cylinder${i}`, {
            height: 2, diameterTop: 0.3, diameterBottom: 0.5
          }, this.scene);
          cylinder.position = new BABYLON.Vector3(
            (Math.random() - 0.5) * 10,
            1,
            (Math.random() - 0.5) * 10
          );
          const cylinderMaterial = new BABYLON.StandardMaterial(`cylinderMaterial${i}`, this.scene);
          cylinderMaterial.diffuseColor = new BABYLON.Color3(
            Math.random() * 0.5 + 0.5,
            Math.random() * 0.5 + 0.5,
            Math.random() * 0.5 + 0.5
          );
          cylinder.material = cylinderMaterial;
          this.sceneObjects.push(cylinder);
        }
      }
      
      setupLighting() {
        // ç’°å¢ƒå…‰
        const ambientLight = new BABYLON.HemisphericLight("ambientLight", 
          new BABYLON.Vector3(0, 1, 0), this.scene);
        ambientLight.intensity = 0.3;
        
        // ä¸»è¦é»å…‰æº
        const mainLight = new BABYLON.PointLight("mainLight", 
          new BABYLON.Vector3(3, 5, 3), this.scene);
        mainLight.intensity = 0.8;
        mainLight.diffuse = new BABYLON.Color3(1, 1, 1);
        
        // å‹•ç•«å…‰æº
        BABYLON.Animation.CreateAndStartAnimation("mainLightAnimation", mainLight, "position", 
          30, 300, new BABYLON.Vector3(3, 5, 3), new BABYLON.Vector3(-3, 5, -3),
          BABYLON.Animation.ANIMATIONLOOPMODE_YOYO);
        
        // è¼”åŠ©å½©è‰²å…‰æº
        const colorLight = new BABYLON.PointLight("colorLight", 
          new BABYLON.Vector3(-3, 5, 3), this.scene);
        colorLight.intensity = 0.6;
        colorLight.diffuse = new BABYLON.Color3(1, 0.42, 0.42);
        
        // æ–¹å‘å…‰
        const directionalLight = new BABYLON.DirectionalLight("directionalLight", 
          new BABYLON.Vector3(0, -1, 0), this.scene);
        directionalLight.intensity = 0.4;
        directionalLight.diffuse = new BABYLON.Color3(0.53, 0.81, 0.92);
      }
      
      setupEventListeners() {
        // æŒ‰éˆ•äº‹ä»¶
        this.toggleBtn.addEventListener("click", () => this.toggleCamera());
        
        // éµç›¤äº‹ä»¶
        document.addEventListener("keydown", (e) => this.handleKeyDown(e));
        document.addEventListener("keyup", (e) => this.handleKeyUp(e));
        
        // è¦–çª—å¤§å°è®ŠåŒ–
        window.addEventListener("resize", () => this.handleResize());
        
        // å®šæœŸæ›´æ–°UIä¿¡æ¯
        setInterval(() => {
          this.updatePositionInfo();
        }, 50);
      }
      
      handleKeyDown(e) {
        if (e.repeat) return;
        
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            this.toggleCamera();
            break;
          case 'KeyR':
            e.preventDefault();
            this.resetCamera();
            break;
          case 'KeyC':
            e.preventDefault();
            this.toggleCrosshair();
            break;
          case 'KeyG':
            e.preventDefault();
            this.toggleDebugMode();
            break;
          case 'KeyW':
            if (this.isOrtho) {
              e.preventDefault();
              this.keys.orthoShrink = true;
            } else {
              this.keys.forward = true;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              e.preventDefault();
              this.keys.orthoGrow = true;
            } else {
              this.keys.backward = true;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = true;
            break;
          case 'ArrowDown':
            this.keys.backward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = true;
            break;
        }
      }
      
      handleKeyUp(e) {
        switch(e.code) {
          case 'KeyW':
            if (this.isOrtho) {
              this.keys.orthoShrink = false;
            } else {
              this.keys.forward = false;
            }
            break;
          case 'KeyS':
            if (this.isOrtho) {
              this.keys.orthoGrow = false;
            } else {
              this.keys.backward = false;
            }
            break;
          case 'ArrowUp':
            this.keys.forward = false;
            break;
          case 'ArrowDown':
            this.keys.backward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = false;
            break;
        }
      }
      
      toggleDebugMode() {
        this.debugMode = !this.debugMode;
        this.debugInfo.style.display = this.debugMode ? 'block' : 'none';
        console.log(`èª¿è©¦æ¨¡å¼: ${this.debugMode ? 'é–‹å•Ÿ' : 'é—œé–‰'}`);
      }
      
      toggleCrosshair() {
        this.crosshairVisible = !this.crosshairVisible;
        this.crosshair.style.display = this.crosshairVisible ? 'block' : 'none';
      }
      
      updateCrosshairStyle() {
        if (!this.crosshair) return;
        
        const circle = this.crosshair.querySelector('.crosshair-circle');
        if (!circle) return;
        
        if (this.isOrtho) {
          circle.style.borderColor = 'rgba(0, 255, 136, 0.9)';
          circle.style.boxShadow = '0 0 12px rgba(0, 255, 136, 0.4), inset 0 0 12px rgba(0, 255, 136, 0.15)';
        } else {
          circle.style.borderColor = 'rgba(255, 255, 255, 0.8)';
          circle.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1)';
        }
      }
      
      getViewDirectionDistance() {
        const ray = new BABYLON.Ray(
          this.currentCamera.position.clone(),
          this.currentCamera.getDirection(BABYLON.Vector3.Forward())
        );
        
        const hit = this.scene.pickWithRay(ray, (mesh) => {
          return this.sceneObjects.includes(mesh);
        });
        
        if (hit && hit.hit) {
          const distance = hit.distance;
          return Math.max(0.3, Math.min(30, distance));
        }
        
        return 8.0; // é»˜èªè·é›¢
      }
      
      toggleCamera() {
        const currentDistance = this.getViewDirectionDistance();
        
        if (!this.isOrtho) {
          this.switchToOrthographic(currentDistance);
        } else {
          this.switchToPerspective(currentDistance);
        }
        
        this.updateCameraInfo();
        this.updateCrosshairStyle();
      }
      
      switchToOrthographic(distance) {
        // ä¿å­˜é€è¦–ç›¸æ©Ÿç‹€æ…‹
        const position = this.perspectiveCamera.position.clone();
        const target = this.perspectiveCamera.getTarget().clone();
        const currentFov = this.perspectiveCamera.fov;
        
        // è¨ˆç®—æ­£äº¤å°ºå¯¸
        this.orthoSize = 2 * Math.tan(currentFov / 2) * distance;
        this.orthoSize = Math.max(0.2, Math.min(80, this.orthoSize));
        
        // æ›´æ–°æ­£äº¤ç›¸æ©Ÿ
        this.orthographicCamera.position = position;
        this.orthographicCamera.setTarget(target);
        
        const aspect = this.canvas.width / this.canvas.height;
        this.orthographicCamera.orthoLeft = -this.orthoSize * aspect / 2;
        this.orthographicCamera.orthoRight = this.orthoSize * aspect / 2;
        this.orthographicCamera.orthoTop = this.orthoSize / 2;
        this.orthographicCamera.orthoBottom = -this.orthoSize / 2;
        
        // åˆ‡æ›ç›¸æ©Ÿ
        this.perspectiveCamera.detachControls();
        this.orthographicCamera.attachControls(this.canvas);
        this.scene.activeCamera = this.orthographicCamera;
        this.currentCamera = this.orthographicCamera;
        
        this.isOrtho = true;
        this.label.textContent = "æ­£äº¤æ¨¡å¼";
        
        if (this.debugMode) {
          this.debugContent.innerHTML = `åˆ‡æ›åˆ°æ­£äº¤<br>FOV: ${(currentFov * 180 / Math.PI).toFixed(1)}Â°<br>è·é›¢: ${distance.toFixed(1)}<br>å°ºå¯¸: ${this.orthoSize.toFixed(1)}`;
        }
      }
      
      switchToPerspective(distance) {
        // ä¿å­˜æ­£äº¤ç›¸æ©Ÿç‹€æ…‹
        const position = this.orthographicCamera.position.clone();
        const target = this.orthographicCamera.getTarget().clone();
        
        // è¨ˆç®—FOV
        const tanHalfFov = this.orthoSize / (2 * distance);
        const fov = 2 * Math.atan(tanHalfFov);
        this.savedPerspectiveFov = Math.max(Math.PI / 18, Math.min(2 * Math.PI / 3, fov));
        
        // æ›´æ–°é€è¦–ç›¸æ©Ÿ
        this.perspectiveCamera.position = position;
        this.perspectiveCamera.setTarget(target);
        this.perspectiveCamera.fov = this.savedPerspectiveFov;
        
        // åˆ‡æ›ç›¸æ©Ÿ
        this.orthographicCamera.detachControls();
        this.perspectiveCamera.attachControls(this.canvas);
        this.scene.activeCamera = this.perspectiveCamera;
        this.currentCamera = this.perspectiveCamera;
        
        this.isOrtho = false;
        this.label.textContent = "é€è¦–æ¨¡å¼";
        
        if (this.debugMode) {
          this.debugContent.innerHTML = `åˆ‡æ›åˆ°é€è¦–<br>å°ºå¯¸: ${this.orthoSize.toFixed(1)}<br>è·é›¢: ${distance.toFixed(1)}<br>FOV: ${(this.savedPerspectiveFov * 180 / Math.PI).toFixed(1)}Â°`;
        }
      }
      
      resetCamera() {
        // é‡ç½®åˆ°é»˜èªä½ç½®
        this.currentCamera.position = this.defaultPosition.clone();
        this.currentCamera.setTarget(this.defaultTarget);
        
        // é‡ç½®ç›¸æ©Ÿåƒæ•¸
        if (this.isOrtho) {
          this.orthoSize = 5.0;
          const aspect = this.canvas.width / this.canvas.height;
          this.orthographicCamera.orthoLeft = -this.orthoSize * aspect / 2;
          this.orthographicCamera.orthoRight = this.orthoSize * aspect / 2;
          this.orthographicCamera.orthoTop = this.orthoSize / 2;
          this.orthographicCamera.orthoBottom = -this.orthoSize / 2;
        } else {
          this.perspectiveCamera.fov = this.defaultFov;
          this.savedPerspectiveFov = this.defaultFov;
        }
        
        // é‡ç½®é€Ÿåº¦
        this.velocity.set(0, 0, 0);
        this.orthoSizeVelocity = 0;
        
        this.updateCameraInfo();
      }
      
      updateMovement() {
        // è¨ˆç®—ç›®æ¨™ç§»å‹•æ–¹å‘
        const targetVelocity = new BABYLON.Vector3(0, 0, 0);
        
        if (this.keys.forward) targetVelocity.z -= 1;
        if (this.keys.backward) targetVelocity.z += 1;
        if (this.keys.left) targetVelocity.x -= 1;
        if (this.keys.right) targetVelocity.x += 1;
        
        // æ­£è¦åŒ–ç§»å‹•å‘é‡
        if (targetVelocity.length() > 0) {
          targetVelocity.normalize();
          targetVelocity.scaleInPlace(this.moveSpeed);
        }
        
        // å¹³æ»‘ç§»å‹•
        this.velocity = BABYLON.Vector3.Lerp(this.velocity, targetVelocity, 0.3);
        
        // æ‡‰ç”¨æ‘©æ“¦åŠ›
        if (targetVelocity.length() === 0) {
          this.velocity.scaleInPlace(0.9);
        }
        
        // å¦‚æœé€Ÿåº¦å¾ˆå°å°±åœæ­¢
        if (this.velocity.length() < 0.001) {
          this.velocity.set(0, 0, 0);
        }
        
        // æ‡‰ç”¨ç§»å‹•åˆ°ç›¸æ©Ÿ
        if (this.velocity.length() > 0) {
          const moveVector = this.velocity.clone();
          // ä½¿ç”¨ç›¸æ©Ÿçš„è®Šæ›çŸ©é™£ä¾†è®Šæ›ç§»å‹•æ–¹å‘
          const rotationMatrix = BABYLON.Matrix.RotationYawPitchRoll(
            this.currentCamera.rotation.y,
            this.currentCamera.rotation.x,
            this.currentCamera.rotation.z
          );
          
          const transformedMove = BABYLON.Vector3.TransformCoordinates(moveVector, rotationMatrix);
          this.currentCamera.position.addInPlace(transformedMove);
        }
      }
      
      updateOrthoSize() {
        if (!this.isOrtho) return;
        
        // è¨ˆç®—ç›®æ¨™å°ºå¯¸è®ŠåŒ–
        let targetSizeChange = 0;
        if (this.keys.orthoShrink) targetSizeChange -= this.orthoSizeSpeed;
        if (this.keys.orthoGrow) targetSizeChange += this.orthoSizeSpeed;
        
        // å¹³æ»‘è®ŠåŒ–
        this.orthoSizeVelocity = BABYLON.Scalar.Lerp(this.orthoSizeVelocity, targetSizeChange, 0.3);
        
        // æ‡‰ç”¨æ‘©æ“¦åŠ›
        if (targetSizeChange === 0) {
          this.orthoSizeVelocity *= 0.9;
        }
        
        // å¦‚æœè®ŠåŒ–å¾ˆå°å°±åœæ­¢
        if (Math.abs(this.orthoSizeVelocity) < 0.001) {
          this.orthoSizeVelocity = 0;
        }
        
        // æ‡‰ç”¨å°ºå¯¸è®ŠåŒ–
        if (this.orthoSizeVelocity !== 0) {
          this.orthoSize += this.orthoSizeVelocity;
          this.orthoSize = Math.max(0.5, Math.min(50, this.orthoSize));
          
          const aspect = this.canvas.width / this.canvas.height;
          this.orthographicCamera.orthoLeft = -this.orthoSize * aspect / 2;
          this.orthographicCamera.orthoRight = this.orthoSize * aspect / 2;
          this.orthographicCamera.orthoTop = this.orthoSize / 2;
          this.orthographicCamera.orthoBottom = -this.orthoSize / 2;
          
          // åŸºäºå½“å‰è·ç¦»è®¡ç®—å¯¹åº”çš„FOV
          const currentDistance = this.getViewDirectionDistance();
          const tanHalfFov = this.orthoSize / (2 * currentDistance);
          const fov = 2 * Math.atan(tanHalfFov);
          this.savedPerspectiveFov = Math.max(Math.PI / 18, Math.min(2 * Math.PI / 3, fov));
          
          this.updateCameraInfo();
        }
      }
      
      updateCameraInfo() {
        const distance = this.getViewDirectionDistance();
        
        if (this.isOrtho) {
          const correspondingFovDegrees = (this.savedPerspectiveFov * 180 / Math.PI).toFixed(0);
          this.cameraInfo.innerHTML = `å°ºå¯¸: ${this.orthoSize.toFixed(1)} | æ­£äº¤æŠ•å½±<br>è·é›¢æª¢æ¸¬: ${distance.toFixed(1)}m | å°æ‡‰FOV: ${correspondingFovDegrees}Â°`;
        } else {
          const fovDegrees = (this.perspectiveCamera.fov * 180 / Math.PI).toFixed(0);
          this.cameraInfo.innerHTML = `FOV: ${fovDegrees}Â° | é€è¦–æŠ•å½±<br>è·é›¢æª¢æ¸¬: ${distance.toFixed(1)}m`;
        }
      }
      
      updatePositionInfo() {
        if (!this.currentCamera) return;
        
        const pos = this.currentCamera.position;
        const rotation = this.currentCamera.rotation;
        
        this.positionInfo.textContent = 
          `ä½ç½®: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`;
        
        this.rotationInfo.textContent = 
          `æ—‹è½‰: (${(rotation.x * 180 / Math.PI).toFixed(0)}Â°, ${(rotation.y * 180 / Math.PI).toFixed(0)}Â°, ${(rotation.z * 180 / Math.PI).toFixed(0)}Â°)`;
      }
      
      updatePerformanceInfo() {
        // æ¯å¸§æ›´æ–°FPSè®¡ç®—
        const currentTime = performance.now();
        const deltaTime = currentTime - this.lastTime;
        
        // å°†å¸§æ—¶é—´æ·»åŠ åˆ°ç¼“å†²åŒº
        this.frameTimeBuffer.push(deltaTime);
        if (this.frameTimeBuffer.length > this.bufferSize) {
          this.frameTimeBuffer.shift();
        }
        
        // æ¯30å¸§æ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
        if (this.frameCount % 30 === 0 && this.frameTimeBuffer.length > 10) {
          const avgFrameTime = this.frameTimeBuffer.reduce((sum, time) => sum + time, 0) / this.frameTimeBuffer.length;
          this.fps = Math.round(1000 / avgFrameTime);
          
          const objectCount = this.sceneObjects.length;
          this.performanceInfo.textContent = `FPS: ${this.fps} | ç‰©ä»¶: ${objectCount} | å¼•æ“: Babylon.js`;
        }
        
        this.lastTime = currentTime;
        this.frameCount++;
      }
      
      handleResize() {
        this.engine.resize();
        
        // æ›´æ–°æ­£äº¤ç›¸æ©Ÿçš„ç¸±æ©«æ¯”
        if (this.isOrtho) {
          const aspect = this.canvas.width / this.canvas.height;
          this.orthographicCamera.orthoLeft = -this.orthoSize * aspect / 2;
          this.orthographicCamera.orthoRight = this.orthoSize * aspect / 2;
          this.orthographicCamera.orthoTop = this.orthoSize / 2;
          this.orthographicCamera.orthoBottom = -this.orthoSize / 2;
        }
      }
      
      startRenderLoop() {
        this.engine.runRenderLoop(() => {
          // æ›´æ–°ç§»å‹•
          this.updateMovement();
          
          // æ›´æ–°æ­£äº¤å°ºå¯¸
          this.updateOrthoSize();
          
          // æ›´æ–°æ€§èƒ½ä¿¡æ¯
          this.updatePerformanceInfo();
          
          // æ¸²æŸ“å ´æ™¯
          this.scene.render();
        });
      }
    }
    
    // ç­‰å¾…é é¢åŠ è¼‰å®Œæˆå¾Œåˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', () => {
      new BabylonCameraController();
    });
    
    // è™•ç†é é¢å¸è¼‰
    window.addEventListener('beforeunload', () => {
      if (window.babylonController && window.babylonController.engine) {
        window.babylonController.engine.dispose();
      }
    });
  </script>
</body>
</html>